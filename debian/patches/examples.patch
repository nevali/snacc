diff -uraN snacc-1.3bbn/c++-examples/any/README snacc-1.3b4/c++-examples/any/README
--- snacc-1.3bbn/c++-examples/any/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/any/README	1997-02-16 20:25:26.000000000 +0000
@@ -0,0 +1,90 @@
+(RCS control information is at the end of this file.)
+
+
+C++ ANY example README
+---------------------
+
+This example shows how the snacc compiler handles the ANY DEFINED BY
+type in C++.  ANY types (not ANY DEFINED BY) require modifications
+to the generated code.  Type "make" to build this example.
+
+This directory should have the following 4 files in it:
+
+        README
+        example.C
+        genber.C
+        makefile
+
+There are 3 programs generated by the makefile:
+
+        genber - builds a BER value of the AnyTestType and writes it
+                 to a file called "att.ber"
+
+        def    - takes file name of an AnyTestType BER value.  Decodes the
+                 file and re-encodes it to stdout.  Uses definite
+                 lengths for constructed values.
+
+        indef  - takes file name of an AnyTestType BER value.  Decodes the
+                 file and re-encodes it to stdout.  Uses indefinite
+                 lengths for constructed values.
+
+
+These files use the code generated by snacc from the
+snacc/asn1specs/any.asn1 file. (see the makefile)
+
+Look at genber.C to see how values can be built and printed.
+
+Look at the generated code in any_test.C and any_test.h to see how the
+any hash table is built.
+
+
+try the following commands in your c-shell:
+
+%1 genber                   # generate the att.ber file
+%2 indef att.ber > tmp.ber  # decode att.ber an re-encode into tmp.ber
+%3 def tmp.ber > tmp2.ber   # decode tmp.ber an re-encode into tmp2.ber
+%4 diff att.ber tmp2.ber    # compare .ber files (should be the same)
+
+When you are finished with the example type "make clean"  to remove
+the binaries and generated code.
+
+
+
+Things To Note
+--------------
+
+Snacc ASN.1 comment commands
+
+In the snacc/asn1specs/any.asn1 file, the AnyTestType has a special
+"--snacc" ASN.1 comment after ::= to give snacc some extra information
+about the AnyTestType.
+
+AnyTestType ::= --snacc isPdu:"TRUE" -- SEQUENCE { ... etc. ... }
+
+The "isPdu" flag only affects the generated C code, not C++.  Each
+C++ type gets PDU methods by default.
+
+
+SNMP OBJECT-TYPE Macro
+
+The SNMP OBJECT-TYPE macro is used to define the id value to type
+mapping for ANY DEFINED BY types.  The macro has been modified to
+accept both INTEGERs and OBJECT IDENTIFIERs as id values (see
+snacc/asn1specs/any.asn1).  This macro can be used with other
+protocols to define the id to type mapping.
+
+Two hash tables are used to hold the id to type mappings. One for
+INTEGER to type mappings and the other for OBJECT IDENTIFIER to type
+mappings.  The hash tables are automatically initialized in each
+module that has OBJECT-TYPE macros.  In C the hash table must be
+explicitly initialized.
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/any/README,v 1.2 1997/02/16 20:25:26 rj Exp $
+# $Log: README,v $
+# Revision 1.2  1997/02/16 20:25:26  rj
+# check-in of a few cosmetic changes
+#
+# Revision 1.1  1994/08/31  08:47:59  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c++-examples/any/example.C snacc-1.3b4/c++-examples/any/example.C
--- snacc-1.3bbn/c++-examples/any/example.C	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/any/example.C	1995-07-24 15:33:33.000000000 +0000
@@ -0,0 +1,115 @@
+// c++_examples/any/example.C - an example of how to use C++ ASN.1-BER
+//              for ANY Types
+//
+// AUTHOR: Mike Sample
+// DATE:   92
+//
+// $Header: /usr/app/odstb/CVS/snacc/c++-examples/any/example.C,v 1.5 1995/07/24 15:33:33 rj Exp $
+// $Log: example.C,v $
+// Revision 1.5  1995/07/24 15:33:33  rj
+// changed `_' to `-' in file names.
+//
+// any-test.[hC] becomes any.[hC] due to to snacc's new file name generation scheme.
+//
+// check return value of new.
+//
+// Revision 1.4  1995/02/18  13:53:07  rj
+// added #define HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS since not every C++ compiler provides them.
+//
+// Revision 1.3  1994/10/08  01:26:21  rj
+// several \size_t'
+//
+// Revision 1.2  1994/08/31  08:56:29  rj
+// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+//
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fstream.h>
+
+#include "asn-incl.h"
+#include "any.h"
+
+main (int argc, char *argv[])
+{
+    if (argc != 2)
+    {
+        cerr << "Usage: " << argv[0] << " <BER data file name>" << endl;
+        cerr << "   Decodes the given AnyTestType BER data file" << endl;
+        cerr << "   and re-encodes it to stdout" << endl;
+        exit (1);
+    }
+
+    ifstream dataFile;
+    // open the data file
+    dataFile.open (argv[1]);
+
+    if (!dataFile)
+    {
+        perror ("ifstream::open");
+        exit (1);
+    }
+
+    // get size of the data file file
+    dataFile.seekg (0, ios::end);
+    int dataSize = dataFile.tellg();
+    dataFile.seekg (0);
+
+    // read data from file into contiguous block for a buffer
+#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
+    char data[dataSize];
+#else
+    char *data = new char[dataSize];
+    if (!data)
+	return 1;
+#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
+    dataFile.read (data, dataSize);
+    dataFile.close();
+
+    //
+    // put the BER data read from the file
+    // into buffer format, ready for reading from the
+    // beginning
+    //
+    AsnBuf inputBuf;
+    inputBuf.InstallData ((char*)data, dataSize);
+
+    size_t decodedLen;
+    AnyTestType att;
+
+    if (!att.BDecPdu (inputBuf, decodedLen))
+    {
+        cerr << "ERROR - Decode routines failed, exiting..." << endl;
+        exit (1);
+    }
+
+    cerr  << "decodedValue AnyTestType ::= " << att << endl << endl;
+
+    //
+    // allocate a new buffer and set up for writing to
+    //
+    AsnBuf  outputBuf;
+#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
+    char outputData[dataSize + 512];
+#else
+    char *outputData = new char[dataSize + 512];
+    if (!outputData)
+	return 1;
+#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
+    outputBuf.Init (outputData, dataSize+512);
+    outputBuf.ResetInWriteRvsMode();
+
+    size_t encodedLen;
+    if (!att.BEncPdu (outputBuf, encodedLen))
+    {
+        cerr << "ERROR - Encode routines failed" << endl;
+    }
+
+    // write the BER value to cout
+    outputBuf.ResetInReadMode();
+    for ( ; encodedLen > 0; encodedLen--)
+        cout.put (outputBuf.GetByte());
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c++-examples/any/genber.C snacc-1.3b4/c++-examples/any/genber.C
--- snacc-1.3bbn/c++-examples/any/genber.C	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/any/genber.C	1995-07-24 15:33:34.000000000 +0000
@@ -0,0 +1,150 @@
+// c++_examples/any/genber.C - builds an AnyTestType value and writes BER form
+//            of the value to a file called "att.ber"
+//
+//  Shows how to build internal rep of lists and ANY values.
+//
+// MS 92
+//
+// $Header: /usr/app/odstb/CVS/snacc/c++-examples/any/genber.C,v 1.5 1995/07/24 15:33:34 rj Exp $
+// $Log: genber.C,v $
+// Revision 1.5  1995/07/24 15:33:34  rj
+// changed `_' to `-' in file names.
+//
+// any-test.[hC] becomes any.[hC] due to to snacc's new file name generation scheme.
+//
+// check return value of new.
+//
+// Revision 1.4  1995/02/18  13:54:03  rj
+// added #define HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS since not every C++ compiler provides them.
+//
+// Revision 1.3  1994/10/08  01:26:22  rj
+// several \size_t'
+//
+// Revision 1.2  1994/08/31  08:56:30  rj
+// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+//
+
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fstream.h>
+
+#include "asn-incl.h"
+#include "any.h"
+
+
+main (int argc, char *argv[])
+{
+    ofstream outputFile;
+    AsnBuf outputBuf;
+    size_t encodedLen;
+    size_t dataSize = 1024;
+#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
+    char data[dataSize];
+#else
+    char *data = new char[dataSize];
+    if (!data)
+	return 1;
+#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
+    AnyTestType att;
+    TSeq1 ts1;
+    TSeq2 ts2;
+    AttrValue1 *atv1ptr;
+    AttrValue2 *atv2ptr;
+    AsnInt intVal;
+    AsnBool boolVal;
+    AsnOcts octsVal ("Hi Mom");
+    OctsId octsIdVal = octsVal;
+    AsnBits bitsVal;
+    BitsId bitsIdVal (9);
+    AsnReal realVal;
+
+    // READ THIS!!!
+    // you must be really careful when setting the
+    // "value" field and "id" fields in an
+    // ANY/ANY DEFINED BY type because "value" is a
+    // "AsnType*" and will accept any
+    // pointer value.  It will even encode
+    // the wrong value without complaining if you
+    // set "value" to the wrong object.
+
+    atv1ptr = att.intMap.Append();
+    atv1ptr->id = intId;
+    intVal = -99;
+    atv1ptr->anyDefBy.value = &intVal;
+
+    atv1ptr = att.intMap.Append();
+    atv1ptr->id = boolId;
+    boolVal = true;
+    atv1ptr->anyDefBy.value = &boolVal;
+
+    atv1ptr = att.intMap.Append();
+    atv1ptr->id = octsId;
+    atv1ptr->anyDefBy.value = &octsIdVal;
+
+    atv1ptr = att.intMap.Append();
+    atv1ptr->id = bitsId;
+    bitsIdVal.SetBit (0);
+    bitsIdVal.ClrBit (1);
+    bitsIdVal.SetBit (2);
+    bitsIdVal.ClrBit (3);
+    bitsIdVal.SetBit (4);
+    bitsIdVal.ClrBit (5);
+    bitsIdVal.SetBit (6);
+    bitsIdVal.ClrBit (7);
+    bitsIdVal.SetBit (8);
+    bitsIdVal.ClrBit (9);
+    atv1ptr->anyDefBy.value = &bitsIdVal;
+
+    atv1ptr = att.intMap.Append();
+    atv1ptr->id = realId;
+    realVal = 108.3838;
+    atv1ptr->anyDefBy.value = &realVal;
+
+    // now do TSeq2 with same vals but use OID as identifier
+    atv2ptr = att.oidMap.Append();
+    atv2ptr->id = intOid;
+    atv2ptr->anyDefBy.value = &intVal;
+
+    atv2ptr = att.oidMap.Append();
+    atv2ptr->id = boolOid;
+    atv2ptr->anyDefBy.value = &boolVal;
+
+    atv2ptr = att.oidMap.Append();
+    atv2ptr->id = octsOid;
+    atv2ptr->anyDefBy.value = &octsVal;
+
+    atv2ptr = att.oidMap.Append();
+    atv2ptr->id = bitsOid;
+    bitsVal = bitsIdVal; // copy bits
+    atv2ptr->anyDefBy.value = &bitsVal;
+
+    atv2ptr = att.oidMap.Append();
+    atv2ptr->id = realOid;
+    atv2ptr->anyDefBy.value = &realVal;
+
+    outputBuf.Init (data, dataSize);
+    outputBuf.ResetInWriteRvsMode();
+
+    if (!att.BEncPdu (outputBuf, encodedLen))
+        cout << "failed encoding AnyTestType value" << endl;
+
+    outputFile.open ("att.ber");
+    if (!outputFile)
+    {
+        perror ("ofstream::open");
+        exit (1);
+    }
+
+    outputBuf.ResetInReadMode();
+    for ( ; encodedLen > 0; encodedLen--)
+        outputFile.put (outputBuf.GetByte());
+
+
+    cout << "Wrote the following BER AnyTestType value to att.ber." << endl;
+    cout << "Test it with \"def\" and \"indef\"" << endl;
+    cout << att << endl;
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c++-examples/any/makefile snacc-1.3b4/c++-examples/any/makefile
--- snacc-1.3bbn/c++-examples/any/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/any/makefile	1997-02-16 16:47:46.000000000 +0000
@@ -0,0 +1,154 @@
+# c++-examples/any/makefile
+#
+# WARNING: this makefile isn't safe for parallel making!
+#
+# builds the C++ ANY example
+#
+# MS 92
+#
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/any/makefile,v 1.9 1997/02/16 16:47:46 rj Exp $
+# $Log: makefile,v $
+# Revision 1.9  1997/02/16 16:47:46  rj
+# made return *this after calling abort()'' a compile time option.
+#
+# Revision 1.8  1995/07/24  15:29:07  rj
+# useful.asn1 renamed to asn-useful.asn1 to accomodate to snacc's new file name generation scheme.
+# any-test.[hC] becomes any.[hC] due to to snacc's new file name generation scheme.
+#
+# `cd && make' instead of `cd; make'.
+#
+# changed `_' to `-' in file names.
+#
+# Revision 1.7  1995/02/20  11:46:19  rj
+# build snacc if it doesn't exist.
+# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
+#
+# Revision 1.6  1995/02/13  14:58:12  rj
+# augment CPPFLAGS, not overwrite
+#
+# Revision 1.5  1994/10/08  04:35:42  rj
+# enhance portability by using standard make capabilities instead of utilies (basename, dirname) not found on every platform.
+#
+# for the dependencies, generate the snacc compiler if it doesn't exist.
+#
+# Revision 1.4  1994/09/01  02:26:53  rj
+# use CXX instead of CC to get another default linkage
+#
+# Revision 1.3  1994/08/31  21:38:34  rj
+# rebuild the executables when the c++-lib is newer.
+#
+# Revision 1.2  1994/08/31  10:31:47  rj
+# since .o files get moved, a few more dependencies are needed.
+#
+# Revision 1.1  1994/08/31  08:48:03  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_SRC_DIR	= $(TOP)/asn1specs
+
+ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
+ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
+ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
+
+COMPILERDIR	= $(TOP)/compiler
+SNACC		= $(COMPILERDIR)/snacc
+USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
+SNACCFLAGS	= -C $(SNACC_NOVOLAT) -u $(USEFUL_TYPES)
+
+CC		= $(CXX)
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR) $(LENFLAG)
+
+ASN1FILES	= $(ASN1_SRC_DIR)/any.asn1
+
+# generated by snacc from any.asn1:
+ASN1HFILES	= any.h
+ASN1CFILES	= any.C
+
+CFILES = \
+	genber.C	\
+	example.C
+
+DISTFILES = \
+	README		\
+	makefile	\
+	$(CFILES)
+
+#-------------------------------------------------------------------------------
+
+all::		genber def indef
+
+$(ASN1HFILES)	\
+$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
+		$(REASON)
+		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
+
+$(SNACC):
+		cd $(@D) && $(MAKE) $(@F)
+
+def-obj		\
+indef-obj:
+		mkdir $@
+
+def-obj/any.o	\
+def-obj/example.o:
+		$(REASON)
+		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+indef-obj/any.o	\
+indef-obj/example.o:
+		$(REASON)
+		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+genber:		def-obj/any.o genber.o
+		$(REASON)
+		$(CXX) $(LDFLAGS) -o $@ def-obj/any.o genber.o $(ASN1_C++_LIB) $(LIBS)
+
+def: 		def-obj/any.o def-obj/example.o
+		$(REASON)
+		$(CXX) $(LDFLAGS) -o $@ def-obj/any.o def-obj/example.o $(ASN1_C++_LIB) $(LIBS)
+
+indef:		indef-obj/any.o indef-obj/example.o
+		$(REASON)
+		$(CXX) $(LDFLAGS) -o $@ indef-obj/any.o indef-obj/example.o $(ASN1_C++_LIB) $(LIBS)
+
+genber	\
+def	\
+indef:		$(ASN1_C++_LIB)
+
+.PHONY:	check
+
+check::		genber def indef
+		$(RM) foo.ber bar.ber
+		./genber
+		./indef att.ber > foo.ber
+		./def foo.ber > bar.ber
+		@echo ''
+		@if cmp -s bar.ber att.ber; then\
+		  echo "+++ Passed simple encode/decode tests using any.asn1.";\
+		else\
+		  echo "--- Failed simple encode/decode tests using any.asn1.";\
+		fi
+		@echo ''
+		$(RM) foo.ber bar.ber
+
+clean::
+		$(RM) *.o *~ .emacs* core def indef genber att.ber $(ASN1HFILES) $(ASN1CFILES)
+		$(RM) -r def-obj indef-obj
+		$(RM) foo.ber bar.ber
+
+depend::	$(SNACC)
+
+include ../../maketail
+
+depend::
+		cp dependencies deps
+		for dir in def-obj indef-obj; do\
+		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
+		done
+		mv deps dependencies
diff -uraN snacc-1.3bbn/c++-examples/makefile snacc-1.3b4/c++-examples/makefile
--- snacc-1.3bbn/c++-examples/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/makefile	1995-07-24 15:25:37.000000000 +0000
@@ -0,0 +1,34 @@
+# file: .../c++-examples/makefile
+
+SUBDIRS		= test-lib simple any snmp
+
+#-------------------------------------------------------------------------------
+
+.PHONY:	implicit_default
+implicit_default::
+		$(MAKE) subdirs
+
+subdirs::	$(SUBDIRS)
+$(SUBDIRS)::
+		cd $@ && $(MAKE) $(subtarget)
+
+# the following hack is needed for older make versions (gmake doesn't need it):
+init-depend::
+		@for dir in $(SUBDIRS); do\
+		  test -f $$dir/dependencies || touch $$dir/dependencies;\
+		done
+
+.DEFAULT::
+		$(MAKE) subdirs subtarget=$@
+
+distfiles::
+		echo makefile
+		for dir in $(SUBDIRS); do\
+		  subfiles=`cd $$dir && $(MAKE) -s $@`;\
+		  for file in $$subfiles; do\
+		    echo "$$dir/$$file";\
+		  done;\
+		done
+
+# dummy:
+install::
diff -uraN snacc-1.3bbn/c++-examples/simple/README snacc-1.3b4/c++-examples/simple/README
--- snacc-1.3bbn/c++-examples/simple/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/simple/README	1994-10-08 04:43:46.000000000 +0000
@@ -0,0 +1,105 @@
+(RCS control information is at the end of this file.)
+
+
+C++ Simple Example README
+-------------------------
+
+This directory should have 6 files in it:
+
+  README      - this file
+
+  genber.C    - C++ source code for a program that creates and encodes
+                a PersonnelRecord value to a file.
+
+  example.C   - C++ source code for a program that decodes a given
+                PersonnelRecord value and re-encodes it to stdout.
+
+  makefile    - compiles the example programs
+
+  good_pr.ber - BER encoding of a Personnel Record (all definite lengths)
+
+
+
+Type "make" to generate the 3 example programs:
+        genber
+        def
+        indef
+
+
+
+snacc is called from the makefile on .../asn1specs/p_rec.asn1 to
+generate the following files:
+
+p_rec.h  - C++ classes for PersonnelRecord types.
+
+p_rec.C  - C++ source code for the PersonnelRecord encode, decode,
+           print, and free methods.
+
+These source files are then compiled with example.C to make the
+programs def and indef.  Each program takes 1 argument, the name of a
+file containing an BER encoded PersonnelRecord value.
+
+
+Try the following:
+
+%1 genber                       # create a file called pr.ber
+%2 indef good_pr.ber > indef_pr.ber
+%3 def indef_pr.ber > def_pr.ber
+%4 diff good_pr.ber def_pr.ber  # should be no differences
+
+(commands 2-4 can be made via the `check' phony target.)
+
+The above commands decode the BER value in "good_pr.ber" and
+indef_pr.ber respectively and then re-encode them to stdout.
+Both programs will decode any valid BER representation of a
+PersonnelRecord value but, the def program will re-encode the
+given data using only the definite length BER format and the
+indef program will re-encode the given data using only the
+indefinite length BER format.
+
+Compare the lengths of the def_pr.ber and indef_pr.ber files,
+indefinite length encodings are usually larger.
+
+
+
+Things to Note
+--------------
+
+Look at genber.C to see how to build a C++ value and then encode it.
+look at the example.C file to see buffer usage.  Look at
+.../c++_lib/inc/asn_config.h and .../c++_lib/inc/asn_buf.h if you
+want to change the buffer managment.
+
+
+Snacc ASN.1 comment commands
+
+Notice the special "--snacc" ASN.1 comment in .../asn1specs/p_rec.asn1.
+
+PersonnelRecord ::= --snacc isPdu:"TRUE" -- [APPLICATION 0] IMPLICIT SET
+ { ... etc. ... }
+
+The "isPdu" flag tells snacc that the PersonnelRecord is a PDU type.
+This flag has no effect on the generated C++ code, since each type gets
+PDU members automatically for C++.
+
+
+
+Length formats
+
+Both the def and indef programs were generated from the same source
+file, example.c.  Indefinite length encoders can be created by giving
+the -DUSE_INDEF_LEN flag to the C++ compiler when compiling.  Currently
+the indefinite/definite length encoder choice is made a compile time.
+To change this to a run-time decision, a simple solution would be to
+modify BerEncodeConsLen and BerEncodeEocIfNec macros in
+.../c++_lib/inc/asn_len.h to check a global flag.
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/simple/README,v 1.2 1994/10/08 04:43:46 rj Exp $
+# $Log: README,v $
+# Revision 1.2  1994/10/08 04:43:46  rj
+# the test csh skript has been integrated into the makefile
+#
+# Revision 1.1  1994/08/31  08:48:05  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c++-examples/simple/example.C snacc-1.3b4/c++-examples/simple/example.C
--- snacc-1.3bbn/c++-examples/simple/example.C	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/simple/example.C	1995-07-24 15:36:03.000000000 +0000
@@ -0,0 +1,115 @@
+// c++_examples/simple/example.C - an example of how to use  C++ ASN.1-BER
+//             encoders and decoders generated by snacc
+//
+// AUTHOR: Mike Sample
+// DATE:   Aug 92
+//
+// $Header: /usr/app/odstb/CVS/snacc/c++-examples/simple/example.C,v 1.5 1995/07/24 15:36:03 rj Exp $
+// $Log: example.C,v $
+// Revision 1.5  1995/07/24 15:36:03  rj
+// check return value of new.
+//
+// changed `_' to `-' in file names.
+//
+// Revision 1.4  1995/02/18  13:54:18  rj
+// added #define HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS since not every C++ compiler provides them.
+//
+// Revision 1.3  1994/10/08  01:27:02  rj
+// several \size_t'
+//
+// Revision 1.2  1994/08/31  08:56:32  rj
+// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+//
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fstream.h>
+#include "asn-incl.h"
+#include "p-rec.h"
+
+
+main (int argc, char *argv[])
+{
+    AsnBuf  inputBuf;
+    AsnBuf  outputBuf;
+    size_t encodedLen;
+    size_t decodedLen;
+    size_t      dataSize;
+    ifstream dataFile;
+    PersonnelRecord pr;
+
+    if (argc != 2)
+    {
+        cerr << "Usage: " << argv[0] << " <BER data file name>" << endl;
+        cerr << "   Decodes the given PersonnelRecord BER data file" << endl;
+        cerr << "   and re-encodes it to stdout" << endl;
+        exit (1);
+    }
+
+
+    // open the data file
+    dataFile.open (argv[1]);
+
+    if (!dataFile)
+    {
+        perror ("ifstream::open");
+        exit (1);
+    }
+
+    // get size of the data file file
+    dataFile.seekg (0, ios::end);
+    dataSize = dataFile.tellg();
+    dataFile.seekg (0);
+
+    // read data from file into contiguous block for a buffer
+#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
+    char data[dataSize];
+#else
+    char *data = new char[dataSize];
+    if (!data)
+	return 1;
+#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
+    dataFile.read (data, dataSize);
+    dataFile.close();
+
+    //
+    // put the BER data read from the file
+    // into buffer format, ready for reading from the
+    // beginning
+    //
+    inputBuf.InstallData (data, dataSize);
+
+    if (!pr.BDecPdu (inputBuf, decodedLen))
+    {
+        cerr << "--- ERROR - Decode routines failed, exiting..." << endl;
+        exit (1);
+    }
+
+    cerr  << "decodedValue PersonnelRecord ::= " << pr << endl << endl;
+
+    //
+    // allocate a new buffer set up for writing to
+    //
+#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
+    char outputData[dataSize + 512];
+#else
+    char *outputData = new char[dataSize + 512];
+    if (!outputData)
+	return 1;
+#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
+    outputBuf.Init (outputData, dataSize+512);
+    outputBuf.ResetInWriteRvsMode();
+
+    if (!pr.BEncPdu (outputBuf, encodedLen))
+    {
+        cerr << "--- ERROR - Encode routines failed" << endl;
+    }
+
+    // write the BER value to cout
+    outputBuf.ResetInReadMode();
+    for (; encodedLen > 0; encodedLen--)
+        cout.put (outputBuf.GetByte());
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c++-examples/simple/genber.C snacc-1.3b4/c++-examples/simple/genber.C
--- snacc-1.3bbn/c++-examples/simple/genber.C	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/simple/genber.C	1995-07-24 15:40:32.000000000 +0000
@@ -0,0 +1,99 @@
+// file: .../c++examples/simple/genber.C---builds an PersonnelRecord value and writes BER form of the value to a file called "pr.ber"
+//
+// MS 92
+//
+// $Header: /usr/app/odstb/CVS/snacc/c++-examples/simple/genber.C,v 1.5 1995/07/24 15:40:32 rj Exp $
+// $Log: genber.C,v $
+// Revision 1.5  1995/07/24 15:40:32  rj
+// changed `_' to `-' in file names.
+//
+// Revision 1.4  1994/12/11  15:36:14  rj
+// const for a constant value [DEC]
+//
+// Revision 1.3  1994/10/08  01:27:03  rj
+// several \size_t'
+//
+// Revision 1.2  1994/08/31  08:56:33  rj
+// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+//
+
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fstream.h>
+
+#include "asn-incl.h"
+#include "p-rec.h"
+
+
+main (int argc, char *argv[])
+{
+    ofstream outputFile;
+    AsnBuf outputBuf;
+    size_t encodedLen;
+    const size_t dataSize = 1024;
+    char data[dataSize];
+    ChildInformation *ciPtr;
+    PersonnelRecord pr;
+
+    // build internal value of a PersonnelRecord
+    pr.name = new Name;
+    pr.name->givenName = "John";  // this calls pr.name->givenName.Set ("John");
+    pr.name->initial = "E";
+    pr.name->familyName = "Smith";
+
+    pr.title.Set ("The Big Cheese");
+    pr.employeeNumber = 99999;
+    pr.dateOfHire.Set ("19820104");
+
+    pr.nameOfSpouse = new Name;
+    pr.nameOfSpouse->givenName.Set ("Mary");
+    pr.nameOfSpouse->initial.Set ("L");
+    pr.nameOfSpouse->familyName.Set ("Smith");
+
+    pr.children = new PersonnelRecordSeqOf;
+
+    ciPtr = pr.children->Append();
+    ciPtr->name = new Name;
+    ciPtr->name->givenName.Set ("James");
+    ciPtr->name->initial.Set ("R");
+    ciPtr->name->familyName.Set ("Smith");
+    ciPtr->dateOfBirth.Set ("19570310");
+
+    ciPtr = pr.children->Append();
+    ciPtr->name = new Name;
+    ciPtr->name->givenName.Set ("Lisa");
+    ciPtr->name->initial.Set ("M");
+    ciPtr->name->familyName.Set ("Smith");
+    ciPtr->dateOfBirth.Set ("19610621");
+
+
+    // set up buffer for writing to
+    outputBuf.Init (data, dataSize);
+    outputBuf.ResetInWriteRvsMode();
+
+    // encode the internal value we just build into the buffer
+    if (!pr.BEncPdu (outputBuf, encodedLen))
+        cout << "failed encoding AnyTestType value" << endl;
+
+    // open file to hold the BER value
+    outputFile.open ("pr.ber");
+    if (!outputFile)
+    {
+        perror ("ofstream::open");
+        exit (1);
+    }
+
+    // copy the BER value from the buffer to the file
+    outputBuf.ResetInReadMode();
+    for (; encodedLen > 0; encodedLen--)
+        outputFile.put (outputBuf.GetByte());
+
+
+    cout << "Wrote the following BER PersonnelRecord value to pr.ber." << endl;
+    cout << "Test it with \"def\" and \"indef\"." << endl;
+    cout << pr << endl;
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c++-examples/simple/good-pr.ber.uu snacc-1.3b4/c++-examples/simple/good-pr.ber.uu
--- snacc-1.3bbn/c++-examples/simple/good-pr.ber.uu	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/simple/good-pr.ber.uu	2005-07-30 16:55:52.183500816 +0000
@@ -0,0 +1,7 @@
+begin 644 good-pr.ber
+M8(&,81`6!$IO:&X6`446!5-M:71HH!`6#E1H92!":6<@0VAE97-E0@,!AI^A
+M"D,(,3DX,C`Q,#2B$F$0%@1-87)Y%@%,%@53;6ET:*-!,1]A$18%2F%M97,6
+M`5(6!5-M:71HH`I#"#$Y-3<P,S$P,1YA$!8$3&ES818!318%4VUI=&B@"D,(
+(,3DV,3`V,C$`
+`
+end
diff -uraN snacc-1.3bbn/c++-examples/simple/makefile snacc-1.3b4/c++-examples/simple/makefile
--- snacc-1.3bbn/c++-examples/simple/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/simple/makefile	1997-02-16 16:47:58.000000000 +0000
@@ -0,0 +1,146 @@
+# c++-examples/simple/makefile
+#
+# WARNING: this makefile isn't safe for parallel making!
+#
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/simple/makefile,v 1.9 1997/02/16 16:47:58 rj Exp $
+# $Log: makefile,v $
+# Revision 1.9  1997/02/16 16:47:58  rj
+# made return *this after calling abort()'' a compile time option.
+#
+# Revision 1.8  1995/07/24  15:29:44  rj
+# `cd && make' instead of `cd; make'.
+#
+# changed `_' to `-' in file names.
+#
+# Revision 1.7  1995/02/20  11:47:37  rj
+# build snacc if it doesn't exist.
+# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
+#
+# Revision 1.6  1995/02/13  14:58:14  rj
+# augment CPPFLAGS, not overwrite
+#
+# Revision 1.5  1994/10/08  04:35:59  rj
+# enhance portability by using standard make capabilities instead of utilies (basename, dirname) not found on every platform.
+#
+# for the dependencies, generate the snacc compiler if it doesn't exist.
+#
+# Revision 1.4  1994/09/01  02:26:54  rj
+# use CXX instead of CC to get another default linkage
+#
+# Revision 1.3  1994/08/31  21:40:00  rj
+# rebuild the executables when the c++-lib is newer.
+# the file good-pr.ber needs to be distributed.
+#
+# Revision 1.2  1994/08/31  10:31:50  rj
+# since .o files get moved, a few more dependencies are needed.
+#
+# Revision 1.1  1994/08/31  08:48:10  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_SRC_DIR	= $(TOP)/asn1specs
+
+ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
+ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
+ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
+
+COMPILERDIR	= $(TOP)/compiler
+SNACC		= $(COMPILERDIR)/snacc
+USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
+SNACCFLAGS	= -C $(SNACC_NOVOLAT) -u $(USEFUL_TYPES)
+
+CC		= $(CXX)
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR) $(LENFLAG)
+
+ASN1FILES	= $(ASN1_SRC_DIR)/p-rec.asn1
+
+# generated by snacc from p-rec.asn1:
+ASN1HFILES	= p-rec.h
+ASN1CFILES	= p-rec.C
+
+CFILES = \
+	genber.C	\
+	example.C
+
+DISTFILES = \
+	README		\
+	makefile	\
+	$(CFILES)	\
+	good-pr.ber
+
+#-------------------------------------------------------------------------------
+
+all::		genber def indef
+
+$(ASN1HFILES)	\
+$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
+		$(REASON)
+		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
+
+$(SNACC):
+		cd $(@D) && $(MAKE) $(@F)
+
+def-obj		\
+indef-obj:
+		mkdir $@
+
+def-obj/p-rec.o	\
+def-obj/example.o:
+		$(REASON)
+		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+indef-obj/p-rec.o	\
+indef-obj/example.o:
+		$(REASON)
+		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+genber:		def-obj/p-rec.o genber.o
+		$(REASON)
+		$(CXX) $(LDFLAGS) -o $@ def-obj/p-rec.o genber.o $(ASN1_C++_LIB) $(LIBS)
+
+def: 		def-obj/p-rec.o def-obj/example.o
+		$(REASON)
+		$(CXX) $(LDFLAGS) -o $@ def-obj/p-rec.o def-obj/example.o $(ASN1_C++_LIB) $(LIBS)
+
+indef:		indef-obj/p-rec.o indef-obj/example.o
+		$(REASON)
+		$(CXX) $(LDFLAGS) -o $@ indef-obj/p-rec.o indef-obj/example.o $(ASN1_C++_LIB) $(LIBS)
+
+genber	\
+def	\
+indef:		$(ASN1_C++_LIB)
+
+.PHONY:	check
+
+check::		def indef
+		$(RM) foo.ber bar.ber
+		./indef good-pr.ber > foo.ber
+		./def foo.ber > bar.ber
+		@if cmp -s bar.ber good-pr.ber; then\
+		  echo "+++ Passed simple encode/decode tests using p-rec.asn1.";\
+		else\
+		  echo "--- Failed simple encode/decode tests using p-rec.asn1.";\
+		fi
+		$(RM) foo.ber bar.ber
+
+clean::
+		$(RM) *.o *~ .emacs* core def indef genber pr.ber $(ASN1HFILES) $(ASN1CFILES)
+		$(RM) -r def-obj indef-obj
+		$(RM) foo.ber bar.ber
+
+depend::	$(SNACC)
+
+include ../../maketail
+
+depend::
+		cp dependencies deps
+		for dir in def-obj indef-obj; do\
+		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
+		done
+		mv deps dependencies
diff -uraN snacc-1.3bbn/c++-examples/snmp/README snacc-1.3b4/c++-examples/snmp/README
--- snacc-1.3bbn/c++-examples/snmp/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/snmp/README	1995-07-27 11:36:13.000000000 +0000
@@ -0,0 +1,126 @@
+(RCS control information is at the end of this file.)
+
+
+C++ SNMP Example - Mike Sample Mar 92
+---------------------------------
+
+This example illustrates a few more features of the compiler than the
+simple example.  It also shows some deficiencies.  No executable
+programs are generated by the makefile, it only generates the snmp
+code and compiles it without linking.
+
+This directory contains 2 files:
+        README
+        makefile
+
+Snacc generates source from the following ASN.1 files:
+        .../asn1specs/rfc1155-smi.asn1
+        .../asn1specs/rfc1157-snmp.asn1
+        .../asn1specs/rfc1213-mib2.asn1
+
+multi-module compilation
+   The IMPORT/EXPORT mechanisms of ASN.1 '88 are supported so you don't
+   have to dump all of the ASN.1 definitions into a single file
+   The order of the ASN.1 file arguments is the order that they
+   are included in the generated source files.  For example:
+
+   %1 snacc rfc1155-smi.asn1 rfc1157-snmp.asn1 rfc1213-mib2.asn1
+
+   causes the order in which hdr files are included in rfc1213-mib2.C
+   to be:
+
+   #include "asn-incl.h"
+   #include "rfc1155-smi.h"
+   #include "rfc1157-snmp.h"
+   #include "rfc1213-mib2.h"
+
+
+    Currently, snacc assumes that each ASN.1 file given on the command
+    line depends on all of the others on the command line.  There is
+    no attempt to compute the dependencies via the import lists alone.
+
+SNMP OBJECT-TYPE macro parsing / ANY type hash table
+   The SNMP OBJECT-TYPE macro is parsed.   This results in the
+   type in the "SYNTAX" part of the macro is put into
+   the ANY type hash table using the  OBJECT-TYPE macro's value as the
+   hash key.  Also if the type in the SYNTAX field is not defined
+   outsided of the macro (could be different tagging etc), a proper
+   type definition is generated for it.  If you want to change the way
+   the macro is handled, modify the corresponding routine in "do_macros.c".
+
+value definitions
+   The OBJECT IDENTIFIER values are turned into statically initialized
+   C++ values and included in the generated source and include file.  This
+   is also done for INTEGER and BOOLEAN values.  More complex values
+   are ignored by the compiler at the moment. (modify parse_vals.c if
+   you want to improve this)
+
+
+-P option of snacc is demonstrated
+   The ASN.1 for the parsed modules is generated from the internal data
+   structure.  This can be useful for making sure the compiler is
+   handling your ASN.1 files correctly.  It is also useful to see how
+   the types are modified and sorted to simplify code generation.
+   (see the file snacc.output after typeing "make")
+
+Deficiencies
+   A deficiency in parsing large integers is shown when parsing the
+   following rfc 1155 types:
+
+                  Counter ::=
+                      [APPLICATION 1]
+                          IMPLICIT INTEGER (0..4294967295)
+
+                  Gauge ::=
+                      [APPLICATION 2]
+                          IMPLICIT INTEGER (0..4294967295)
+
+                  TimeTicks ::=
+                      [APPLICATION 3]
+                          IMPLICIT INTEGER (0..4294967295)
+
+Due the size of a C long int the above ASN.1 is represented internally as:
+
+Counter ::= [APPLICATION 1] IMPLICIT INTEGER (0..-1)
+
+Gauge ::= [APPLICATION 2] IMPLICIT INTEGER (0..-1)
+
+TimeTicks ::= [APPLICATION 3] IMPLICIT INTEGER (0..-1)
+
+The ASN.1 library contains routines for encoding/decoding unsigned
+long integers but you must hand code the cases where it is used - the
+compiler never generates code that calls them.
+
+Note also that the produced code for the SNMP ASN.1 must be modified
+to correclty handle the "Opaque" data type.  SNMP does not use the ANY
+DEFINED BY type in an effort to simplify things.  Instead an OCTET
+STRING is used to hold and encoded value whose type is defined by an
+OBJECT IDENTIFIER.  With some simple modifications you can use the
+snacc AsnAnyDefinedBy type instead of the OCTET STRING to achieve
+the desired results.
+
+This should underline the danger of blindly trusting the compiler to
+do the right thing for protocols such as SNMP or X.500 where the type
+of an encoded value depends on a mechanism outside of ASN.1 or the ANY
+type (ANY DEFINED BY types should work automatically).
+
+There is a problem when generating C++ code with the SNMP ASN.1 files.
+Several of the ASN.1 value names conflict with C++ keywords.  The
+generated code will not compile properly as a result.  The best way to
+fix these is to modify the ASN.1 files directly.  The compiler will
+munge field or type names to avoid conflicts with the target language
+but currently does not check value names.  The SNMP ASN.1 module shows
+this problem the with value "private" in rfc1155-smi.asn1.
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/snmp/README,v 1.3 1995/07/27 11:36:13 rj Exp $
+# $Log: README,v $
+# Revision 1.3  1995/07/27 11:36:13  rj
+# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
+#
+# Revision 1.2  1995/07/24  15:41:22  rj
+# changed `_' to `-' in file names.
+#
+# Revision 1.1  1994/08/31  08:48:13  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c++-examples/snmp/makefile snacc-1.3b4/c++-examples/snmp/makefile
--- snacc-1.3bbn/c++-examples/snmp/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/snmp/makefile	1997-02-16 16:48:08.000000000 +0000
@@ -0,0 +1,103 @@
+# c++-examples/snmp/makefile
+#
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/snmp/makefile,v 1.10 1997/02/16 16:48:08 rj Exp $
+# $Log: makefile,v $
+# Revision 1.10  1997/02/16 16:48:08  rj
+# made return *this after calling abort()'' a compile time option.
+#
+# Revision 1.9  1995/07/27  11:59:01  rj
+# rfc1213-mib -> rfc1213-mib2
+#
+# Revision 1.8  1995/07/27  08:29:58  rj
+# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
+#
+# Revision 1.7  1995/07/24  15:30:11  rj
+# `cd && make' instead of `cd; make'.
+#
+# changed `_' to `-' in file names.
+#
+# Revision 1.6  1995/02/20  11:48:41  rj
+# build snacc if it doesn't exist.
+#
+# Revision 1.5  1995/02/13  14:58:15  rj
+# augment CPPFLAGS, not overwrite
+#
+# Revision 1.4  1994/10/08  04:36:28  rj
+# for the dependencies, generate the snacc compiler if it doesn't exist.
+#
+# Revision 1.3  1994/09/01  02:26:56  rj
+# use CXX instead of CC to get another default linkage
+#
+# Revision 1.2  1994/08/31  23:25:41  rj
+# print a less irritating usage.
+#
+# Revision 1.1  1994/08/31  08:48:14  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_SPEC_DIR	= $(TOP)/asn1specs
+
+ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
+ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
+ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
+
+COMPILERDIR	= $(TOP)/compiler
+SNACC		= $(COMPILERDIR)/snacc
+
+CC		= $(CXX)
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR)
+
+ASN1FILES = \
+	$(ASN1_SPEC_DIR)/rfc1155-smi.asn1	\
+	$(ASN1_SPEC_DIR)/rfc1157-snmp.asn1	\
+	$(ASN1_SPEC_DIR)/rfc1213-mib2.asn1
+
+ASN1HFILES = \
+	rfc1155-smi.h	\
+	rfc1213-mib2.h	\
+	rfc1157-snmp.h
+
+ASN1CFILES = \
+	rfc1155-smi.C	\
+	rfc1213-mib2.C	\
+	rfc1157-snmp.C
+
+DISTFILES = \
+	README		\
+	makefile	\
+
+#-------------------------------------------------------------------------------
+
+default::	warning
+
+warning::
+		@echo ''
+		@echo 'read the README and enter `$(MAKE) fail` to test for yourself'
+		@echo ''
+
+fail::		$(ASN1HFILES) $(ASN1CFILES)
+		$(CXX) $(CPPFLAGS) $(CFLAGS) -c $(ASN1CFILES)
+
+$(ASN1HFILES)	\
+$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
+		$(REASON)
+		$(SNACC) -P -C $(SNACC_NOVOLAT) $(ASN1FILES) > snacc.output~
+		mv snacc.output~ snacc.output
+
+$(SNACC):
+		cd $(@D) && $(MAKE) $(@F)
+
+check::
+		@echo "the purpose of this directories' contents is to show deficiencies."
+		@echo "if you want to exercise 'em, make the phony target "'`'"fail'"
+
+clean::
+		$(RM) *.o *~ .emacs* core $(ASN1HFILES) $(ASN1CFILES) snacc.output
+
+depend::	$(SNACC)
+
+include ../../maketail
diff -uraN snacc-1.3bbn/c++-examples/test-lib/README snacc-1.3b4/c++-examples/test-lib/README
--- snacc-1.3bbn/c++-examples/test-lib/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/test-lib/README	1997-02-16 20:25:29.000000000 +0000
@@ -0,0 +1,37 @@
+(RCS control information is at the end of this file.)
+
+
+C++ test_lib README
+-------------------
+
+This directory should have 3 files:
+        README - this file
+        makefile
+        test_lib.C
+
+Type "make" to compile test_lib.
+
+test_lib tests each encode and decode routine in the C++ ASN.1
+runtime library. Errors will be reported.
+
+test_lib should be run for each machine architecture you install snacc on.
+If you modify the library routines you should run test_lib again.
+
+The general testing methodology is:
+        1. test the buffer routines
+        2. test tags
+        3. test lengths
+        4. test each libarary type.
+
+For each type, a range of values is encoded and then decoded
+and and compared with the original value.
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/test-lib/README,v 1.2 1997/02/16 20:25:29 rj Exp $
+# $Log: README,v $
+# Revision 1.2  1997/02/16 20:25:29  rj
+# check-in of a few cosmetic changes
+#
+# Revision 1.1  1994/08/31  08:48:16  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c++-examples/test-lib/makefile snacc-1.3b4/c++-examples/test-lib/makefile
--- snacc-1.3bbn/c++-examples/test-lib/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/test-lib/makefile	1997-03-03 11:58:30.000000000 +0000
@@ -0,0 +1,59 @@
+# c++-examples/test-lib/makefile
+#
+# $Header: /usr/app/odstb/CVS/snacc/c++-examples/test-lib/makefile,v 1.7 1997/03/03 11:58:30 wan Exp $
+# $Log: makefile,v $
+# Revision 1.7  1997/03/03 11:58:30  wan
+# Final pre-delivery stuff (I hope).
+#
+# Revision 1.6  1997/02/28 13:39:41  wan
+# Modifications collected for new version 1.3: Bug fixes, tk4.2.
+#
+# Revision 1.5  1995/07/24 15:31:14  rj
+# changed `_' to `-' in file names.
+#
+# Revision 1.4  1995/02/13  14:58:17  rj
+# augment CPPFLAGS, not overwrite
+#
+# Revision 1.3  1994/09/01  02:26:58  rj
+# use CXX instead of CC to get another default linkage
+#
+# Revision 1.2  1994/08/31  21:44:25  rj
+# rebuild the executables when the c++-lib is newer.
+#
+# Revision 1.1  1994/08/31  08:48:17  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
+ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
+ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
+
+CC		= $(CXX)
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR)
+
+CFILES = \
+	test-lib.C
+
+DISTFILES = \
+	README		\
+	makefile	\
+	$(CFILES)
+
+#-------------------------------------------------------------------------------
+
+default::	check
+
+check::		test-lib
+		./test-lib
+
+test-lib:	$(ASN1_C++_LIB) test-lib.o
+		$(CXX) $(LDFLAGS) -o $@ test-lib.o $(ASN1_C++_LIB) $(LIBS)
+
+clean::
+		$(RM) *.o *~ .emacs* test-lib core
+
+include ../../maketail
diff -uraN snacc-1.3bbn/c++-examples/test-lib/test-lib.C snacc-1.3b4/c++-examples/test-lib/test-lib.C
--- snacc-1.3bbn/c++-examples/test-lib/test-lib.C	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c++-examples/test-lib/test-lib.C	1997-02-28 13:39:42.000000000 +0000
@@ -0,0 +1,781 @@
+// c++_examples/test_lib/test_lib.C
+//
+// $Header: /usr/app/odstb/CVS/snacc/c++-examples/test-lib/test-lib.C,v 1.5 1997/02/28 13:39:42 wan Exp $
+// $Log: test-lib.C,v $
+// Revision 1.5  1997/02/28 13:39:42  wan
+// Modifications collected for new version 1.3: Bug fixes, tk4.2.
+//
+// Revision 1.4  1995/07/24 15:44:10  rj
+// #error "..." instead of #error ...
+//
+// changed `_' to `-' in file names.
+//
+// function and file names adjusted.
+//
+// Revision 1.3  1995/02/18  16:40:08  rj
+// utilize either isinf(3) or finite(3), whatever happens to be present.
+//
+// Revision 1.2  1994/08/31  08:56:35  rj
+// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+//
+
+#include <stdio.h>
+#include <iostream.h>
+#include "asn-incl.h"
+
+
+int TestAsnBuffers();
+int TestAsnTag();
+int TestAsnLen();
+int TestAsnBool();
+int TestAsnInt();
+int TestAsnReal();
+int TestAsnOcts();
+int TestAsnBits();
+int TestAsnOid();
+int TestAsnList();
+
+const int bufSize = 256;
+
+int main()
+{
+    int isErr = false;
+
+    if (!TestAsnBuffers())
+    {
+        cout << "Failed buffer tests, no point in proceeding ... bye!" << endl;
+        return 1;
+    }
+
+    if (!TestAsnTag())
+    {
+        cout << "Failed Tag test." << endl;
+        isErr = true;
+    }
+
+    if (!TestAsnLen())
+    {
+        cout << "Failed Length test." << endl;
+        isErr = true;
+    }
+
+    if (!TestAsnBool())
+    {
+        cout << "Failed BOOLEAN test." << endl;
+        isErr = true;
+    }
+
+
+    if (!TestAsnInt())
+    {
+        cout << "Failed INTEGER test." << endl;
+        isErr = true;
+    }
+
+    if (!TestAsnOcts())
+    {
+        cout << "Failed OCTET STRING test." << endl;
+        isErr = true;
+    }
+
+
+    if (!TestAsnBits())
+    {
+        cout << "Failed BIT STRING test." << endl;
+        isErr = true;
+    }
+
+
+    if (!TestAsnOid())
+    {
+        cout << "Failed OBJECT IDENTIFIER test." << endl;
+        isErr = true;
+    }
+
+
+    if (!TestAsnReal())
+    {
+        cout << "Failed REAL test." << endl;
+        isErr = true;
+    }
+
+
+
+    if (isErr)
+    {
+        cout << "There are errors in the primitive type encoding/decoding" << endl;
+        cout << "library for this architecture.  Time for gdb..." << endl;
+    }
+    else
+    {
+        cout << "The primitive type encoding/decoding library passed simple tests." << endl;
+        cout << "It should be safe to use..." << endl;
+    }
+    return isErr;
+}
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnBuffers()
+{
+    AsnBuf  b;
+    char bufData[256];
+    int i,j;
+    int noErr = true;
+
+    // initialize buffer
+    b.Init (bufData, 256);
+    b.ResetInWriteRvsMode();
+
+    // write whole range of byte (0..255)
+    // remember, write works in reverse
+    for (i = 0; i < 256; i++)
+        b.PutByteRvs (i);
+
+    if (b.WriteError())
+    {
+        cout << "Error writing to buffer." << endl;
+        noErr = false;
+    }
+
+    // read in values & verify
+    b.ResetInReadMode();
+    for (i = 255; i >= 0; i--)
+        if (b.GetByte() != i)
+        {
+            cout << "Error verifying data written to buffer." << endl;
+            noErr = false;
+        }
+
+    if (b.ReadError())
+    {
+        cout << "Error reading from buffer." << endl;
+        noErr = false;
+    }
+
+
+    /* now make sure errors are detected */
+    b.ResetInWriteRvsMode();
+
+    for (i = 0; i < 257; i++) // write past end of buffer
+        b.PutByteRvs (0);
+
+    if (!b.WriteError())
+    {
+        cout << "Buffers failed to report buffer write overflow." << endl;
+        noErr = false;
+    }
+
+
+    b.ResetInReadMode();
+    for (i = 256; i >= 0; i--)  // read past end of buffer
+        b.GetByte();
+
+    if (!b.ReadError())
+    {
+        cout << "Buffers failed to report buffer read overflow." << endl;
+        noErr = false;
+    }
+
+    return noErr;
+}  /* TestAsnBuffers */
+
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnTag()
+{
+    AsnTag aTag1;
+    AsnTag aTag2;
+    int i, j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = true;
+    ENV_TYPE env;
+    AsnBuf  b;
+    char bufData[256];
+    long int val;
+    BER_CLASS tagClass;
+    BER_FORM form;
+    BER_UNIV_CODE code;
+
+
+    /* initialize buffer */
+    b.Init (bufData, 256);
+
+    /* encode a TRUE value and verify */
+    tagClass = UNIV;
+    form = PRIM;
+    code = INTEGER_TAG_CODE;
+    aTag1 = MAKE_TAG_ID (tagClass, form, code);
+
+    for (i = 0; i < 2; i++)
+    {
+        b.ResetInWriteRvsMode();
+        len1 = BEncTag1 (b, tagClass, form, code);
+
+        if (b.WriteError())
+        {
+            noErr = false;
+            cout << "Error encoding a Tag." << endl;
+        }
+
+        b.ResetInReadMode();
+
+        aTag2 = 0;
+
+        /* make sure no decode errors and that it decodes to same tag */
+        len2 = 0;
+        if ((val = setjmp (env)) == 0)
+        {
+            aTag2 = BDecTag (b, len2, env);
+        }
+        else
+        {
+            noErr = false;
+            cout << "Error decoding a Tag - error number " << val << endl;
+        }
+        if (noErr && ((aTag2 != aTag1) || (len1 != len2)))
+        {
+            noErr = false;
+            cout << "Error decoded Tag does not match encoded Tag." << endl;
+        }
+        /* set a new test tag value */
+        tagClass = CNTX;
+        form = CONS;
+        code = (BER_UNIV_CODE) 29;
+        aTag1 = MAKE_TAG_ID (tagClass, form, code);
+    }
+    return noErr;
+}  /* TestAsnTag */
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnLen()
+{
+    AsnLen aLen1;
+    AsnLen aLen2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = true;
+    ENV_TYPE env;
+    AsnBuf  b;
+    char bufData[256];
+    long int val;
+
+    /* initialize buffer */
+    b.Init (bufData, 256);
+
+
+    /* encode a TRUE value and verify */
+    aLen1 = 99999;
+    for (i = 0; i < 2; i++)
+    {
+        b.ResetInWriteRvsMode();
+        len1 = BEncDefLen (b, aLen1);
+
+        if (b.WriteError())
+        {
+            noErr = false;
+            cout <<  "Error encoding Length." << endl;
+        }
+
+        b.ResetInReadMode();
+
+        aLen2 = 0;
+
+        /* make sure no decode errors and that it decodes to true */
+        len2 = 0;
+        if ((val = setjmp (env)) == 0)
+        {
+            aLen2 = BDecLen (b, len2, env);
+        }
+        else
+        {
+            noErr = false;
+            cout << "Error decoding Length - error number " << val << endl;
+        }
+
+
+        if (noErr && ((aLen2 != aLen1) || (len1 != len2)))
+        {
+            noErr = false;
+            cout << "Error - decoded length does not match encoded length" << endl;
+        }
+        aLen1 = 2;
+    }
+
+
+    /* test indef len */
+    b.ResetInWriteRvsMode();
+    len1 = BEncIndefLen (b);
+
+    if (b.WriteError())
+    {
+        noErr = false;
+        cout << "Error encoding indefinite Length." << endl;
+    }
+
+    b.ResetInReadMode();
+
+    aLen2 = 0;
+
+    /* make sure no decode errors */
+    len2 = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        aLen2 = BDecLen (b, len2, env);
+    }
+    else
+    {
+        noErr = false;
+        cout << "Error decoding Length - error number " << val << endl;
+    }
+
+
+    if (noErr && ((aLen2 != INDEFINITE_LEN) || (len1 != len2)))
+    {
+        noErr = false;
+        cout << "Error - decoded length does not match encoded length" << endl;
+    }
+
+    /* test EOC */
+    b.ResetInWriteRvsMode();
+    len1 = BEncEoc (b);
+
+    if (b.WriteError())
+    {
+        noErr = false;
+        cout << "Error encoding indefinite Length." << endl;
+    }
+
+    b.ResetInReadMode();
+
+    aLen2 = 0;
+
+    /* make sure no decode errors */
+    len2 = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecEoc (b, len2, env);
+    }
+    else
+    {
+        noErr = false;
+        cout << "Error decoding Length - error number " <<  val << endl;
+    }
+
+
+    if (noErr && (len1 != len2))
+    {
+        noErr = false;
+        cout << "Error - decoded EOC length error" << endl;
+    }
+
+    return noErr;
+}  /* TestAsnLen */
+
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnBool()
+{
+    AsnBuf  b;
+    char bufData[bufSize];
+    AsnBool aBool1;
+    AsnBool aBool2;
+    int j;
+    AsnLen len1;
+    AsnLen len2;
+    int noErr = true;
+
+    // initialize a small buffer
+    b.Init (bufData, bufSize);
+    b.ResetInWriteRvsMode();
+
+    // encode a true value and verify
+    aBool1 = true;
+
+    if (!aBool1.BEncPdu (b, len1))
+    {
+        noErr = false;
+        cout << "Error encoding TRUE BOOLEAN value." << endl;
+    }
+
+    b.ResetInReadMode();
+
+    aBool2 = false; // set to opposite of expected value
+
+    // make sure no decode errors and that it decodes to true
+    if (!aBool2.BDecPdu (b, len2) || !aBool2 || (len1 != len2))
+    {
+        noErr = false;
+        cout << "Error decoding TRUE BOOLEAN value." << endl;
+    }
+
+    // now encode a false value and verify
+    b.ResetInWriteRvsMode();
+    aBool1 = false;
+
+    if (!aBool1.BEncPdu (b, len1))
+    {
+        noErr = false;
+        cout << "Error encoding FALSE BOOLEAN value." << endl;
+    }
+
+    b.ResetInReadMode();
+
+    aBool2 = true; // set to opposite of expected value
+
+    // make sure no decode errors and that it decodes to false
+    if (!aBool2.BDecPdu (b, len2) || aBool2 || (len1 != len2))
+    {
+        noErr = false;
+        cout << "Error decoding FALSE BOOLEAN value." << endl;
+    }
+
+    return noErr;
+}  /* TestAsnBool */
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnInt()
+{
+    AsnBuf  b;
+    char bufData[bufSize];
+    AsnInt a1;
+    AsnInt a2;
+    int i,j, sign;
+    AsnLen len1;
+    AsnLen len2;
+    int noErr = true;
+
+    // initialize a small buffer
+    b.Init (bufData, bufSize);
+
+    //
+    // Encode a range of integers: negative & positive in
+    //  the 1 to sizeof (long int) range
+    //
+
+    sign = 1;
+    for (j = 0; j < 2; j++)
+    {
+        for (i = 0; i < sizeof (long int); i++)
+        {
+            b.ResetInWriteRvsMode();
+
+            a1 = sign * (17 << (i * 8)); // 17 is a random choice
+            if (!a1.BEncPdu (b, len1))
+            {
+                noErr = false;
+                cout << "Error encoding INTEGER value " << a1 << "." << endl;
+            }
+
+            b.ResetInReadMode();
+            a2 = 0;
+
+            // make sure no decode errors and that it decodes to the correc val
+            if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
+            {
+                noErr = false;
+                cout << "Error decoding INTEGER value " << a1 << "." << endl;
+            }
+        }
+        sign = -1;
+    }
+
+    return noErr;
+
+} /* TestAsnInt */
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnOcts()
+{
+    AsnBuf  b;
+    char bufData[bufSize];
+    AsnOcts a1;
+    AsnOcts a2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    int noErr = true;
+
+    // initialize a small buffer
+    b.Init (bufData, bufSize);
+
+    a1 = "Hello Gumby?";
+    for (j = 0; j < 2; j++)
+    {
+        b.ResetInWriteRvsMode();
+
+        if (!a1.BEncPdu (b, len1))
+        {
+            noErr = false;
+            cout << "Error encoding OCTET STRING value " << a1 << "." << endl;
+        }
+
+        b.ResetInReadMode();
+
+        // make sure no decode errors and that it decodes to the correc val
+        if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
+        {
+            noErr = false;
+            cout << "Error decoding OCTET STRING value " << a1 << "." << endl;
+        }
+        a1 = ""; // try an empty string
+    }
+
+    return noErr;
+
+} /* TestAsnOcts */
+
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnBits()
+{
+    AsnBuf  b;
+    char bufData[bufSize];
+    AsnBits a1 (32);
+    AsnBits a2 (32);
+    short bitsToSet[32] = { 0, 1, 0, 0, 1, 1, 0, 1,
+                            0, 1, 0, 0, 1, 1, 0, 1,
+                            0, 1, 0, 0, 1, 1, 0, 1,
+                            0, 1, 0, 0, 1, 1, 0, 1 };
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    int noErr = true;
+
+    // initialize a small buffer
+    b.Init (bufData, bufSize);
+
+
+    // set some bits
+    for (i = 0; i < 32; i++)
+    {
+        if (bitsToSet[i])
+            a1.SetBit (i);
+        else
+            a1.ClrBit (i);
+
+    }
+
+    b.ResetInWriteRvsMode();
+    if (!a1.BEncPdu (b, len1))
+    {
+        noErr = false;
+        cout << "Error encoding BIT STRING value " << a1 << "." << endl;
+    }
+
+    b.ResetInReadMode();
+
+    // make sure no decode errors and that it decodes to the correc val
+    if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
+    {
+        noErr = false;
+        cout << "Error decoding BIT STRING value " << a1 << "." << endl;
+    }
+
+
+    return noErr;
+
+} /* TestAsnBits */
+
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnOid()
+{
+    AsnBuf  b;
+    char bufData[bufSize];
+    AsnOid a1 (0,1,2,3,4,5,6);
+    AsnOid a2;
+    AsnOid a3 (2,38,29,40,200,10,4000);
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    int noErr = true;
+
+    // initialize a small buffer
+    b.Init (bufData, bufSize);
+
+    for (i = 0; i < 2; i++)
+    {
+        b.ResetInWriteRvsMode();
+
+        if (!a1.BEncPdu (b, len1))
+        {
+            noErr = false;
+            cout << "Error encoding OBJECT IDENTIFIER value " << a1 << "." << endl;
+        }
+
+        b.ResetInReadMode();
+
+        // make sure no decode errors and that it decodes to the correc val
+        if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
+        {
+            noErr = false;
+            cout << "Error decoding OBJECT IDENTIFIER value " << a1 << "." << endl;
+        }
+
+        a1 = a3;
+    }
+    return noErr;
+
+} /* TestAsnOid */
+
+/*
+ * returns true if passes encode/decode tests
+ *
+ * NOT USED - nuked template design.
+ */
+/*
+int
+TestAsnList()
+{
+    AsnBuf  b;
+    char bufData[bufSize];
+    AsnList<AsnInt> intList1;
+    AsnList<AsnInt> intList2;
+    AsnList<AsnBool> boolList1;
+    AsnList<AsnBool> boolList2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    int noErr = true;
+
+    b.Init (bufData, bufSize);
+
+    b.ResetInWriteRvsMode();
+
+    if (!intList1.BEncPdu (b, len1))
+    {
+        noErr = false;
+        cout << "Error encoding SEQUENCE OF value " << intList1 << "." << endl;
+    }
+
+    b.ResetInReadMode();
+
+    if (!intList2.BDecPdu (b, len2) || (len1 != len2))
+    {
+        noErr = false;
+        cout << "Error decoding SEQUENCE OF value " << intList1 << "." << endl;
+    }
+    cout << "intlist 1 = "  <<  intList1 << endl;
+    cout << "intlist 2 = "  <<  intList1 << endl;
+
+
+    if (!boolList1.BEncPdu (b, len1))
+    {
+        noErr = false;
+        cout << "Error encoding SEQUENCE OF value " << boolList1 << "." << endl;
+    }
+
+    b.ResetInReadMode();
+
+    if (!boolList2.BDecPdu (b, len2) ||  (len1 != len2))
+    {
+        noErr = false;
+        cout << "Error decoding SEQUENCE OF value " << boolList1 << "." << endl;
+    }
+    cout << "boolList 1 = "  <<  boolList1 << endl;
+    cout << "boolList 2 = "  <<  boolList1 << endl;
+
+    return noErr;
+
+}  TestAsnList */
+
+
+
+/*
+ * returns true if passes encode/decode tests
+ */
+int
+TestAsnReal()
+{
+    AsnBuf  b;
+    char bufData[bufSize];
+    AsnReal  a2;
+    AsnReal  a[] = { 0.0, 0.8, -22.484848, PLUS_INFINITY, MINUS_INFINITY};
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    int noErr = true;
+
+
+    /*
+     * if you do not have the ieee_functions in your math lib,
+     * this will not link.  Comment it out and cross you fingers.
+     * (or check/set the +/-infinity values for you architecture)
+     */
+#if HAVE_ISINF
+    if (!isinf ((double)PLUS_INFINITY)) || !isinf ((double)MINUS_INFINITY))
+#else
+#if HAVE_FINITE
+    if (finite ((double)PLUS_INFINITY) || finite ((double)MINUS_INFINITY))
+#else
+  #error "oops: you've got neither isinf(3) nor finite(3)?!"
+#endif
+#endif
+    {
+        cout << "WARNING: PLUS_INFINITY and MINUS_INFINITY in .../c++-lib/src/asn-real.C are" << endl;
+        cout << "not correct for this architecture.  Modify the AsnPlusInfinity() routine." << endl;
+    }
+
+
+    // initialize a small buffer
+    b.Init (bufData, bufSize);
+
+    for (i = 0; i < 5; i++)
+    {
+        b.ResetInWriteRvsMode();
+
+        if (!a[i].BEncPdu (b, len1))
+        {
+            noErr = false;
+            cout << "Error encoding REAL value " << a[i] << "." << endl;
+        }
+
+        b.ResetInReadMode();
+
+        // make sure no decode errors and that it decodes to the correc val
+        if (!a2.BDecPdu (b, len2) || (a2 != a[i]) || (len1 != len2))
+        {
+            noErr = false;
+            cout << "Error decoding REAL value " << a[i] << "." << endl;
+        }
+    }
+
+    return noErr;
+
+} /* TestAsnReal */
diff -uraN snacc-1.3bbn/c-examples/any/README snacc-1.3b4/c-examples/any/README
--- snacc-1.3bbn/c-examples/any/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/any/README	1997-02-16 20:26:14.000000000 +0000
@@ -0,0 +1,107 @@
+(RCS control information is at the end of this file.)
+
+
+C ANY example README
+------------------
+
+This example shows how the snacc compiler handles the ANY DEFINED BY
+type in C.  ANY types (not ANY DEFINED BY) require the modifications
+to the generated code.  Type "make" to build this example.
+
+This directory should have the following files in it:
+
+        README
+        genber.c
+        example.c
+        makefile
+
+There are 3 programs generated by the makefile:
+
+        genber - builds a BER value of the AnyTestType and writes it
+                 to a file called "att.ber"
+
+        def    - takes file name of an AnyTestType value.  Decodes the
+                 file and re-encodes it to stdout.  Uses definite
+                 lengths for constructed values.
+
+        indef  - takes file name of an AnyTestType value.  Decodes the
+                 file and re-encodes it to stdout.  Uses indefinite
+                 lengths for constructed values.
+
+
+These files use the code generated by snacc from the
+snacc/asn1specs/any.asn1 file. (see the makefile)
+
+Look at genber.c to see how values can be built and printed.
+
+Look at the generated code in any_test.c and any_test.h to see how the
+any hash table is built.
+
+
+try the following commands in your c-shell:
+
+%1 genber                   # generate the att.ber file
+%2 indef att.ber > tmp.ber  # decode att.ber an re-encode into tmp.ber
+%3 def tmp.ber > tmp2.ber   # decode tmp.ber an re-encode into tmp2.ber
+%4 diff att.ber tmp2.ber    # compare .ber files (should be the same)
+
+When you are finished with the example type "make clean"  to remove
+the binaries and generated code.
+
+
+
+Things To Note
+--------------
+
+Snacc ASN.1 comment commands
+
+In the snacc/asn1specs/any.asn1 file, the AnyTestType has a special
+"--snacc" ASN.1 comment after ::= to give snacc some extra information
+about the AnyTestType.
+
+AnyTestType ::= --snacc isPdu:"TRUE" -- SEQUENCE { ... etc. ... }
+
+The "isPdu" flag tells snacc that the AnyTestType is a PDU type that
+you will be calling the encoding and decoding routines directly
+from your code.  This causes snacc to generate the "BEncAnyTestType"
+and "BDecAnyTestType" routines in addition to the standard
+"BEncAnyTestTypeContent" and "BDecAnyTestTypeContent".
+
+The Content encoding and decoding routines only deal with the content
+of the type, ignoring all of the tag and length pairs on the given
+type (in this case the UNIVERSAL (CONSTRUCTED) 16 tag and the length
+for the SEQUENCE).  The "BEncAnyTestType" and "BDecAnyTestType"
+routines do encode the SEQUENCE tag and its length.  This design is
+motivated by IMPLICIT tagging.
+
+The compiler generated routines generally only call the content
+oriented routines except in the case of ANY and ANY DEFINED BY types.
+For ANY and ANY DEFINED BY types the PDU form of the rouine is called
+since the tags are not known by the containing type.
+
+
+SNMP OBJECT-TYPE Macro
+
+The SNMP OBJECT-TYPE macro is used to define the id to type mapping
+for ANY DEFINED BY types.  The macro has been modified to accept both
+INTEGERs and OBJECT IDENTIFIERs as values (see
+snacc/asn1specs/any.asn1).  This macro can be used with other
+protocols to define the id to type mapping.
+
+Two hash tables are used to hold the id to type mappings. One for
+INTEGER to type mappings and the other for OBJECT IDENTIFIER to type
+mappings.  You must explicitly initialize the hash tables by calling
+generated init routines once at the beginning of your program.  Each
+module that has OBJECT-TYPE macros in it will generate an
+"InitAny<module name>" routine.  You must call every init routine to
+add all the mappings to the hash table(s).
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/any/README,v 1.2 1997/02/16 20:26:14 rj Exp $
+# $Log: README,v $
+# Revision 1.2  1997/02/16 20:26:14  rj
+# check-in of a few cosmetic changes
+#
+# Revision 1.1  1994/08/31  08:46:17  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c-examples/any/example.c snacc-1.3b4/c-examples/any/example.c
--- snacc-1.3bbn/c-examples/any/example.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/any/example.c	1997-02-16 20:26:15.000000000 +0000
@@ -0,0 +1,161 @@
+/*
+ * c-examples/any/example.c - an example of how to call C ASN.1-BER
+ *             encoders and decoders generated by snacc
+ *
+ * AUTHOR: Mike Sample
+ * DATE:   Mar 92
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/c-examples/any/example.c,v 1.6 1997/02/16 20:26:15 rj Exp $
+ * $Log: example.c,v $
+ * Revision 1.6  1997/02/16 20:26:15  rj
+ * check-in of a few cosmetic changes
+ *
+ * Revision 1.5  1995/07/24  20:40:19  rj
+ * any-test.[hc] becomes any.[hc] due to to snacc's new file name generation scheme.
+ *
+ * changed `_' to `-' in file names.
+ *
+ * Revision 1.4  1995/02/18  15:17:35  rj
+ * cosmetic changes
+ *
+ * Revision 1.3  1994/08/31  23:45:45  rj
+ * more portable .h file inclusion.
+ *
+ * Revision 1.2  1994/08/31  08:59:31  rj
+ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+ *
+ */
+
+#include "asn-incl.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#if HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+#include <stdio.h>
+
+#include "any.h"
+
+
+
+main PARAMS ((argc, argv),
+    int argc _AND_
+    char *argv[])
+{
+    int fd;
+    SBuf  buf;
+    SBuf  encBuf;
+    char *encData;
+    AsnLen encodedLen;
+    AsnLen decodedLen;
+    int     val;
+    AnyTestType att;
+    int      size;
+    char    *origData;
+    struct stat sbuf;
+    jmp_buf env;
+
+    if (argc != 2)
+    {
+        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
+        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
+        fprintf (stderr, "   and re-encodes it to stdout\n");
+        exit (1);
+    }
+
+    fd = open (argv[1], O_RDONLY, 0);
+    if (fd < 0)
+    {
+        perror ("main: fopen");
+        exit (1);
+    }
+
+    if (fstat (fd, &sbuf) < 0)
+    {
+        perror ("main: fstat");
+        exit (1);
+    }
+
+    size = sbuf.st_size;
+    origData = (char*)malloc (size);
+    if (read (fd, origData, size) != size)
+    {
+        perror ("main: read");
+        exit (1);
+    }
+
+    close (fd);
+
+    /*
+     * puts the given data 'origData' of 'size' bytes
+     * into an SBuf and sets the SBuf up for reading
+     * origData from the beginning
+     */
+    SBufInstallData (&buf, origData, size);
+
+    /*
+     * the first argument (512) is the number of bytes to
+     * initially allocate for the decoder to allocate from.
+     * The second argument (512) is the size in bytes to
+     * enlarge the nibble memory by when it fills up
+     */
+    InitNibbleMem (512, 512);
+
+
+    /*
+     * initialize the hash table for the
+     * the ANY type mappings.
+     * This only needs to be done once per execution
+     * (before any encoding or decoding is done)
+     */
+    InitAnyANY_TEST();
+
+    decodedLen = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecAnyTestType (&buf, &att, &decodedLen, env);
+    }
+    else
+    {
+        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
+        exit (1);
+    }
+
+    fprintf (stderr, "decodedValue AnyTestType ::= ");
+    PrintAnyTestType (stderr, &att, 0);
+    fprintf (stderr, "\n\n");
+
+    /*
+     * setup a new buffer set up for writing.
+     * make sure size is big enough to hold the encoded
+     * value (may be larger than decoded value if encoding
+     * with indef lengths - so add 512 slush bytes)
+     */
+    encData = (char*) malloc (size + 512);
+    SBufInit (&encBuf, encData, size + 512);
+    SBufResetInWriteRvsMode (&encBuf);
+
+    encodedLen =  BEncAnyTestType (&encBuf, &att);
+    if ((encodedLen <= 0) || SBufWriteError (&encBuf))
+    {
+        fprintf (stderr, "ERROR - buffer to hold the encoded value was too small\n");
+        exit (1);
+    }
+
+    /*
+     * free all of the decoded value since
+     * it has been encoded into the buffer.
+     * This is much more efficient than freeing
+     * each compontent of the value individually
+     */
+    ResetNibbleMem();
+
+    /*
+     * write encoded value from encBuf
+     * to stdout
+     */
+    fwrite (SBufDataPtr (&encBuf), SBufDataLen (&encBuf), 1, stdout);
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c-examples/any/genber.c snacc-1.3b4/c-examples/any/genber.c
--- snacc-1.3bbn/c-examples/any/genber.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/any/genber.c	1995-07-24 20:40:50.000000000 +0000
@@ -0,0 +1,164 @@
+/*
+ * c-examples/any/genber.c - builds an AnyTestType value and writes BER form
+ *            of the value to a file called "att.ber"
+ *
+ *  Shows how to build internal rep of lists and ANY values.
+ *
+ *  MS 92
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/c-examples/any/genber.c,v 1.5 1995/07/24 20:40:50 rj Exp $
+ * $Log: genber.c,v $
+ * Revision 1.5  1995/07/24 20:40:50  rj
+ * any-test.[hc] becomes any.[hc] due to to snacc's new file name generation scheme.
+ *
+ * changed `_' to `-' in file names.
+ *
+ * Revision 1.4  1995/02/18  15:17:36  rj
+ * cosmetic changes
+ *
+ * Revision 1.3  1994/08/31  23:48:06  rj
+ * more portable .h file inclusion.
+ *
+ * Revision 1.2  1994/08/31  08:59:32  rj
+ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+ *
+ */
+
+#include <sys/types.h> /* this must be before stddef for gcc-2.3.1 */
+#include <stddef.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <stdio.h>
+
+#include "asn-incl.h"
+#include "any.h"
+
+
+main (int argc, char *argv[])
+{
+    FILE *outputFile;
+    SBuf outputBuf;
+    unsigned long int encodedLen;
+    int dataSize = 1024;
+    int i;
+    char data[1024];
+    AnyTestType att;
+    TSeq1 ts1;
+    TSeq2 ts2;
+    AttrValue1 **atv1Hndl;
+    AttrValue2 **atv2Hndl;
+    AsnInt intVal;
+    AsnBool boolVal;
+    AsnOcts octsVal;
+    AsnBits bitsVal;
+    AsnReal realVal;
+
+    /* used to alloc part of value (Asn1Alloc & AsnListAppend) */
+    InitNibbleMem (512,512);
+
+    /* init id to type ANY hash table */
+    InitAnyANY_TEST();
+
+    att.intMap = AsnListNew (sizeof (void*));
+    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
+    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
+    (*atv1Hndl)->id = intId;  /* the id's are defined in the generated code */
+    intVal = -99;
+    (*atv1Hndl)->anyDefBy.value = (void*) &intVal;
+
+    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
+    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
+    (*atv1Hndl)->id = boolId;
+    boolVal = TRUE;
+    (*atv1Hndl)->anyDefBy.value = (void*)&boolVal;
+
+    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
+    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
+    (*atv1Hndl)->id = octsId;
+    octsVal.octs = "Hi Mom";
+    octsVal.octetLen = strlen (octsVal.octs);
+    (*atv1Hndl)->anyDefBy.value = (void*)&octsVal;
+
+    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
+    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
+    (*atv1Hndl)->id = bitsId;
+    bitsVal.bitLen = 10;
+    bitsVal.bits = (char*)&i;
+    SetAsnBit (&bitsVal, 0);
+    ClrAsnBit (&bitsVal, 1);
+    SetAsnBit (&bitsVal, 2);
+    ClrAsnBit (&bitsVal, 3);
+    SetAsnBit (&bitsVal, 4);
+    ClrAsnBit (&bitsVal, 5);
+    SetAsnBit (&bitsVal, 6);
+    ClrAsnBit (&bitsVal, 7);
+    SetAsnBit (&bitsVal, 8);
+    ClrAsnBit (&bitsVal, 9);
+    (*atv1Hndl)->anyDefBy.value = (void*)&bitsVal;
+
+    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
+    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
+    (*atv1Hndl)->id = realId;
+    realVal = 108.3838;
+    (*atv1Hndl)->anyDefBy.value = (void*)&realVal;
+
+    /* now do TSeq2 with same vals but use OID as identifier */
+    att.oidMap = AsnListNew (sizeof (void*));
+
+    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
+    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
+    (*atv2Hndl)->id = intOid;
+    (*atv2Hndl)->anyDefBy.value = (void*)&intVal;
+
+    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
+    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
+    (*atv2Hndl)->id = boolOid;
+    (*atv2Hndl)->anyDefBy.value = (void*)&boolVal;
+
+    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
+    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
+    (*atv2Hndl)->id = octsOid;
+    (*atv2Hndl)->anyDefBy.value = (void*)&octsVal;
+
+    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
+    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
+    (*atv2Hndl)->id = bitsOid;
+    (*atv2Hndl)->anyDefBy.value = (void*)&bitsVal;
+
+    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
+    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
+    (*atv2Hndl)->id = realOid;
+    (*atv2Hndl)->anyDefBy.value = (void*)&realVal;
+
+    SBufInit (&outputBuf,data, dataSize);
+    SBufResetInWriteRvsMode (&outputBuf);
+
+    encodedLen = BEncAnyTestType (&outputBuf, &att);
+    if ((encodedLen <= 0) || (SBufWriteError (&outputBuf)))
+    {
+        fprintf (stderr, "failed encoding AnyTestType value\n");
+        exit (1);
+    }
+
+    outputFile = fopen ("att.ber", "w");
+    if (!outputFile)
+    {
+        perror ("fopen:");
+        exit (1);
+    }
+
+    SBufResetInReadMode (&outputBuf);
+    for ( ; encodedLen > 0; encodedLen--)
+        fputc (SBufGetByte (&outputBuf), outputFile);
+
+
+    printf ("Wrote the following BER AnyTestType value to att.ber.\n");
+    printf ("Test it with \"def\" and \"indef\"\n");
+
+    PrintAnyTestType (stdout, &att, 0);
+    printf ("\n");
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c-examples/any/makefile snacc-1.3b4/c-examples/any/makefile
--- snacc-1.3bbn/c-examples/any/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/any/makefile	1995-07-24 20:42:31.000000000 +0000
@@ -0,0 +1,144 @@
+# c-examples/any/makefile
+#
+# WARNING: this makefile isn't safe for parallel making!
+#
+#  compile the any example
+#
+# MS 92
+#
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/any/makefile,v 1.6 1995/07/24 20:42:31 rj Exp $
+# $Log: makefile,v $
+# Revision 1.6  1995/07/24 20:42:31  rj
+# useful.asn1 renamed to asn-useful.asn1 to accomodate to snacc's new file name generation scheme.
+# any-test.[hc] becomes any.[hc] due to to snacc's new file name generation scheme.
+#
+# `cd && make' instead of `cd; make'.
+#
+# changed `_' to `-' in file names.
+#
+# Revision 1.5  1995/02/20  11:51:39  rj
+# build snacc if it doesn't exist.
+# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
+#
+# Revision 1.4  1995/02/13  15:05:05  rj
+# augment CPPFLAGS, not overwrite.
+# use $(@D) and $(@F) instead of `dirname $@` and `basename $@` (not every system's got the commands).
+# we need the compiler for the dependencies, so make it if it doesn't yet exist.
+#
+# Revision 1.3  1994/08/31  21:41:37  rj
+# rebuild the executables when the c-lib is newer.
+#
+# Revision 1.2  1994/08/31  10:31:49  rj
+# since .o files get moved, a few more dependencies are needed.
+#
+# Revision 1.1  1994/08/31  08:46:20  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_SRC_DIR	= $(TOP)/asn1specs
+
+ASN1_C_LIB_DIR	= $(TOP)/c-lib
+ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
+ASN1_C_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
+
+COMPILERDIR	= $(TOP)/compiler
+SNACC		= $(COMPILERDIR)/snacc
+USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
+SNACCFLAGS	= -u $(USEFUL_TYPES)
+
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_SBUF $(LENFLAG)
+
+ASN1FILES	= $(ASN1_SRC_DIR)/any.asn1
+
+# generated by snacc from any.asn1:
+ASN1HFILES	= any.h
+ASN1CFILES	= any.c
+
+CFILES = \
+	genber.c	\
+	example.c
+
+DISTFILES = \
+	README		\
+	makefile	\
+	$(CFILES)
+
+#-------------------------------------------------------------------------------
+
+all::		genber def indef
+
+$(ASN1HFILES)	\
+$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
+		$(REASON)
+		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
+
+$(SNACC):
+		cd $(@D) && $(MAKE) $(@F)
+
+def-obj		\
+indef-obj:
+		mkdir $@
+
+def-obj/any.o	\
+def-obj/example.o:
+		$(REASON)
+		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+indef-obj/any.o	\
+indef-obj/example.o:
+		$(REASON)
+		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+genber:		def-obj/any.o genber.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ def-obj/any.o genber.o $(ASN1_C_LIB) $(LIBS)
+
+def: 		def-obj/any.o def-obj/example.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ def-obj/any.o def-obj/example.o $(ASN1_C_LIB) $(LIBS)
+
+indef:		indef-obj/any.o indef-obj/example.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ indef-obj/any.o indef-obj/example.o $(ASN1_C_LIB) $(LIBS)
+
+genber	\
+def	\
+indef:		$(ASN1_C_LIB)
+
+.PHONY:	check
+
+check::		genber def indef
+		$(RM) foo.ber bar.ber
+		./genber
+		./indef att.ber > foo.ber
+		./def foo.ber > bar.ber
+		@echo ''
+		@if cmp -s bar.ber att.ber; then\
+		  echo "+++ Passed simple encode/decode tests using any.asn1.";\
+		else\
+		  echo "--- Failed simple encode/decode tests using any.asn1.";\
+		fi
+		@echo ''
+		$(RM) foo.ber bar.ber
+
+clean::
+		$(RM) *.o *~ .emacs* core def indef genber att.ber $(ASN1HFILES) $(ASN1CFILES)
+		$(RM) -r def-obj indef-obj
+		$(RM) foo.ber bar.ber
+
+depend::	$(SNACC)
+
+include ../../maketail
+
+depend::
+		cp dependencies deps
+		for dir in def-obj indef-obj; do\
+		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
+		done
+		mv deps dependencies
diff -uraN snacc-1.3bbn/c-examples/makefile snacc-1.3b4/c-examples/makefile
--- snacc-1.3bbn/c-examples/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/makefile	1995-07-24 20:38:56.000000000 +0000
@@ -0,0 +1,42 @@
+# c-examples/makefile
+#
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/makefile,v 1.2 1995/07/24 20:38:56 rj Exp $
+# $Log: makefile,v $
+# Revision 1.2  1995/07/24 20:38:56  rj
+# `cd && make' instead of `cd; make'.
+#
+# changed `_' to `-' in file names.
+#
+
+SUBDIRS		= test-lib simple any snmp
+
+#-------------------------------------------------------------------------------
+
+.PHONY:	implicit_default
+implicit_default::
+		$(MAKE) subdirs
+
+subdirs::	$(SUBDIRS)
+$(SUBDIRS)::
+		cd $@ && $(MAKE) $(subtarget)
+
+# the following hack is needed for older make versions (gmake doesn't need it):
+init-depend::
+		@for dir in $(SUBDIRS); do\
+		  test -f $$dir/dependencies || touch $$dir/dependencies;\
+		done
+
+.DEFAULT::
+		$(MAKE) subdirs subtarget=$@
+
+distfiles::
+		echo makefile
+		for dir in $(SUBDIRS); do\
+		  subfiles=`cd $$dir && $(MAKE) -s $@`;\
+		  for file in $$subfiles; do\
+		    echo "$$dir/$$file";\
+		  done;\
+		done
+
+# dummy:
+install::
diff -uraN snacc-1.3bbn/c-examples/simple/README snacc-1.3b4/c-examples/simple/README
--- snacc-1.3bbn/c-examples/simple/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/simple/README	1995-02-17 16:17:24.000000000 +0000
@@ -0,0 +1,128 @@
+(RCS control information is at the end of this file.)
+
+
+C Simple Example README
+-----------------------
+
+This directory should have 8 files in it:
+
+README       - this file
+genber.c     - C source code for a program that creates and encodes
+               a PersonnelRecord value to a file.
+expbuf_ex.c  - C source code for a program that calls the generated
+               PersonnelRecord encoder and decoder routines
+               using the ExpBuf buffer type
+minbuf_ex.c  - C source code for program that calls the generated
+               PersonnelRecord encoder and decoder routines
+               using the MinBuf buffer type
+sbuf_ex.c    - C source code for a program that calls the generated
+               PersonnelRecord encoder and decoder routines
+               using the MinBuf buffer type
+makefile     - compiles the example programs
+good_pr.ber  - BER encoding of a Personnel Record (all definite lengths)
+
+
+
+Type "make" to generate the 7 example programs:
+        genber
+        expbuf_def
+        expbuf_indef
+        minbuf_def
+        minbuf_indef
+        sbuf_def
+        sbuf_indef
+
+
+snacc is called from the makefile on snacc/asn1specs/p_rec.asn1 to
+generate the following files:
+
+p_rec.h  - C data structs for PersonnelRecord and prototypes for
+           the generated encode, decode, print and free routines.
+p_rec.c  - C source code for the PersonnelRecord encode, decode,
+           print, and free routines.
+
+These source files are then compiled with *_ex.c and genber.c files to
+make 7 programs.  Each program takes 1 argument (except genber), the
+name of a file containing an BER encoded PersonnelRecord value.
+
+
+Try the following: (or use the makefile's `check' phony target)
+
+eg% ./genber				# create a file called pr.ber
+eg% ./sbuf_indef good_pr.ber > indef_pr.ber
+eg% ./sbuf_def indef_pr.ber > def_pr.ber
+eg% diff good_pr.ber def_pr.ber		# should be no differences
+
+
+The above commands decode the BER value in "good_pr.ber" and
+indef_pr.ber respectively and then re-encode then to stdout.
+Both programs will decode any valid BER representation of a
+PersonnelRecord value but, the sbuf_def program will re-encode the
+given data using only the definite length BER format and the
+sbuf_indef program will re-encode the given data using only the
+indefinite length BER format.
+
+Compare the lengths of the def_pr.ber and indef_pr.ber files,
+indefinite length encodings are usually larger.
+
+
+
+Things to Note
+--------------
+
+
+Look at genber.c to see how to build a C value and then encode it.
+look at the *_ex.c files to see the different types of buffer
+manipulation.  Read the comments in the code.
+
+It should be relatively simple to change the memory and buffer
+management to fit your target environment.
+(see snacc/c_include/asn_config.h.)
+
+
+Snacc ASN.1 comment commands
+
+Notice the special "--snacc" ASN.1 comment in snacc/asn1specs/p_rec.asn1.
+
+PersonnelRecord ::= --snacc isPdu:"TRUE" -- [APPLICATION 0] IMPLICIT SET
+ { ... etc. ... }
+
+The "isPdu" flag tells snacc that the PersonnelRecord is a PDU type
+that you will be calling the encoding and decoding routines directly
+from your code.  This causes snacc to generate the
+"BEncPersonnelRecord" and "BDecPersonnelRecord" routines in addition
+to the standard "BEncPersonnelRecordContent" and
+"BDecPersonnelRecordContent".
+
+The Content encoding and decoding routines only deal with the content
+of the type, ignoring all of the tag and length pairs on the given
+type (in this case the APPLICATION (CONSTRUCTED) 0 tag and the length
+for the SET).  The "BEncPersonnelRecord" and "BDecPersonnelRecord"
+routines do encode the APPLICATION tag and the SET's length.  This
+design is motivated by IMPLICIT tagging.
+
+The compiler generated routines generally only call the content
+oriented routines except in the case of ANY and ANY DEFINED BY types.
+For ANY and ANY DEFINED BY types the PDU form of the rouine is called
+since the tags are not known by the containing type.
+
+
+Length formats
+
+Each pair of *_def and *_indef programs were generated from the same
+source file, *_ex.c.  Indefinite length encoders can be created by
+giving the -DUSE_INDEF_LEN flag to the C compiler when compiling.
+Currently the indefinite/definite length encoder choice is made a
+compile time.  To change this to a run-time decision, a simple
+solution would be to modify BerEncodeConsLen and BerEncodeEocIfNec
+macros in snacc/c_lib/asn_len.h to check a global flag.
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/simple/README,v 1.2 1995/02/17 16:17:24 rj Exp $
+# $Log: README,v $
+# Revision 1.2  1995/02/17 16:17:24  rj
+# reflect the test script's integration into the makefile.
+#
+# Revision 1.1  1994/08/31  08:46:22  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c-examples/simple/expbuf-ex.c snacc-1.3b4/c-examples/simple/expbuf-ex.c
--- snacc-1.3bbn/c-examples/simple/expbuf-ex.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/simple/expbuf-ex.c	1995-07-24 20:44:58.000000000 +0000
@@ -0,0 +1,166 @@
+/*
+ * c_examples/simple/expbuf_ex.c - an example of how to call C ASN.1-BER
+ *              encoders and decoders generated by snacc
+ *              with the ExpBuf buffer.
+ *
+ * AUTHOR: Mike Sample
+ * DATE:   Mar 92
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/c-examples/simple/expbuf-ex.c,v 1.5 1995/07/24 20:44:58 rj Exp $
+ * $Log: expbuf-ex.c,v $
+ * Revision 1.5  1995/07/24 20:44:58  rj
+ * changed `_' to `-' in file names.
+ *
+ * Revision 1.4  1995/02/18  15:12:53  rj
+ * cosmetic changes
+ *
+ * Revision 1.3  1994/08/31  23:48:29  rj
+ * more portable .h file inclusion.
+ *
+ * Revision 1.2  1994/08/31  08:59:34  rj
+ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+ *
+ */
+
+#include "asn-incl.h"
+
+#include <sys/file.h>
+#include <sys/stat.h>
+#if HAVE_FCNTL_H 
+#include <fcntl.h>
+#endif
+#include <stdio.h>
+
+#include "p-rec.h"
+
+
+main PARAMS ((argc, argv),
+    int argc _AND_
+    char *argv[])
+{
+    int fd;
+    ExpBuf *buf;
+    ExpBuf  b;
+    ExpBuf *tmpBuf;
+    AsnLen encodedLen;
+    AsnLen decodedLen;
+    int     val;
+    PersonnelRecord pr;
+    int      size;
+    char    *origData;
+    struct stat sbuf;
+    jmp_buf env;
+    int  decodeErr;
+    AsnTag tag;
+
+
+    if (argc != 2)
+    {
+        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
+        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
+        fprintf (stderr, "   and re-encodes it to stdout\n");
+        exit (1);
+    }
+
+    fd = open (argv[1], O_RDONLY, 0);
+    if (fd < 0)
+    {
+        perror ("main: fopen");
+        exit (1);
+    }
+
+    if (fstat (fd, &sbuf) < 0)
+    {
+        perror ("main: fstat");
+        exit (1);
+    }
+
+    size = sbuf.st_size;
+    origData = (char*)malloc (size);
+    if (read (fd, origData, size) != size)
+    {
+        perror ("main: read");
+        exit (1);
+    }
+
+    close (fd);
+
+    /*
+     * the "1024" is the size in bytes of the data
+     * blk to allocate when writing to a buffer that
+     * fills up.
+     */
+    ExpBufInit (1024);
+
+    /*
+     * the first argument (512) is the number of bytes to
+     * initially allocate for the decoder to allocate from.
+     * The second argument (512) is the size in bytes to
+     * enlarge the nibble memory by when it fills up
+     */
+    InitNibbleMem (512, 512);
+
+    /*
+     * put the BER data read from the file
+     * into buffer format, ready for reading from the
+     * beginning
+     */
+    buf = &b;
+    ExpBufInstallDataInBuf (buf, origData, size);
+
+    decodedLen = 0;
+    decodeErr = FALSE;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecPersonnelRecord (&buf, &pr, &decodedLen, env);
+    }
+    else
+    {
+        decodeErr = TRUE;
+        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
+    }
+
+    if (decodeErr)
+        exit (1);
+
+    fprintf (stderr, "decodedValue PersonnelRecord ::= ");
+    PrintPersonnelRecord (stderr, &pr, 0);
+    fprintf (stderr, "\n\n");
+
+    /*
+     * allocate a new buffer set up for writing to
+     */
+    buf = ExpBufAllocBufAndData();
+
+    encodedLen =  BEncPersonnelRecord (&buf, &pr);
+
+    /*
+     * Alway check for a buffer write error after encoding
+     */
+    if (ExpBufWriteError (&buf))
+    {
+        fprintf (stderr, "ERROR - buffer write error during encoding\n");
+        exit (1);
+    }
+
+
+    /*
+     * free all of the decoded value since
+     * it has been encoded into the buffer.
+     * This is much more efficient than freeing
+     * each compontent of the value individually
+     */
+    ResetNibbleMem();
+
+    /*
+     * go through buffer (s) and write encoded value
+     * to stdout
+     */
+    buf->curr = buf->dataStart;
+    for ( tmpBuf = buf; tmpBuf != NULL; tmpBuf = tmpBuf->next)
+    {
+        fwrite (tmpBuf->dataStart, tmpBuf->dataEnd - tmpBuf->dataStart, 1, stdout);
+    }
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c-examples/simple/genber.c snacc-1.3b4/c-examples/simple/genber.c
--- snacc-1.3bbn/c-examples/simple/genber.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/simple/genber.c	1995-07-24 20:45:00.000000000 +0000
@@ -0,0 +1,154 @@
+/*
+ * c_examples/simple/genber.c - builds a PersonnelRecord value and writes BER form
+ *            of the value to a file called "pr.ber"
+ *
+ *
+ *  MS 92
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/c-examples/simple/genber.c,v 1.6 1995/07/24 20:45:00 rj Exp $
+ * $Log: genber.c,v $
+ * Revision 1.6  1995/07/24 20:45:00  rj
+ * changed `_' to `-' in file names.
+ *
+ * Revision 1.5  1995/02/18  15:12:54  rj
+ * cosmetic changes
+ *
+ * Revision 1.4  1995/02/17  16:21:03  rj
+ * unnecessary inclusion of <sys/stdtypes.h> removed.
+ *
+ * Revision 1.3  1994/09/01  01:02:37  rj
+ * more portable .h file inclusion.
+ *
+ * Revision 1.2  1994/08/31  08:59:35  rj
+ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+ *
+ */
+
+#include "asn-incl.h"
+
+#include <sys/file.h>
+#include <sys/stat.h>
+
+#include <stddef.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#endif
+#include <errno.h>
+#include <stdio.h>
+
+#include "p-rec.h"
+
+
+main (int argc, char *argv[])
+{
+    FILE *outputFile;
+    SBuf outputBuf;
+    unsigned long int encodedLen;
+    int dataSize = 1024;
+    int i;
+    char data[1024];
+    PersonnelRecord pr;
+    ChildInformation **childHndl;
+
+    /* used to alloc part of value (Asn1Alloc & AsnListAppend) */
+    InitNibbleMem (512,512);
+
+    pr.name = Asn1Alloc (sizeof (Name));
+    pr.name->givenName.octs = "John";
+    pr.name->givenName.octetLen = strlen (pr.name->givenName.octs);
+    pr.name->initial.octs = "E";
+    pr.name->initial.octetLen = strlen (pr.name->initial.octs);
+    pr.name->familyName.octs = "Smith";
+    pr.name->familyName.octetLen = strlen (pr.name->familyName.octs);
+
+    pr.title.octs = "The Big Cheese";
+    pr.title.octetLen = strlen (pr.title.octs);
+
+    pr.employeeNumber = 99999;
+
+    pr.dateOfHire.octs = "19820104";
+    pr.dateOfHire.octetLen = strlen (pr.dateOfHire.octs);
+
+    pr.nameOfSpouse = (Name*) Asn1Alloc (sizeof (Name));
+    pr.nameOfSpouse->givenName.octs = "Mary";
+    pr.nameOfSpouse->givenName.octetLen =
+        strlen (pr.nameOfSpouse->givenName.octs);
+    pr.nameOfSpouse->initial.octs = "L";
+    pr.nameOfSpouse->initial.octetLen = strlen (pr.nameOfSpouse->initial.octs);
+    pr.nameOfSpouse->familyName.octs = "Smith";
+    pr.nameOfSpouse->familyName.octetLen =
+        strlen (pr.nameOfSpouse->familyName.octs);
+
+    pr.children = AsnListNew (sizeof (void*));
+
+    childHndl = AsnListAppend (pr.children);
+    *childHndl = Asn1Alloc (sizeof (ChildInformation));
+
+    (*childHndl)->dateOfBirth.octs = "19570310";
+    (*childHndl)->dateOfBirth.octetLen  = strlen ((*childHndl)->dateOfBirth.octs);
+    (*childHndl)->name = (Name*) Asn1Alloc (sizeof (Name));
+
+    (*childHndl)->name->givenName.octs = "James";
+    (*childHndl)->name->givenName.octetLen =
+        strlen ((*childHndl)->name->givenName.octs);
+    (*childHndl)->name->initial.octs = "R";
+    (*childHndl)->name->initial.octetLen =
+        strlen ((*childHndl)->name->initial.octs);
+    (*childHndl)->name->familyName.octs = "Smith";
+    (*childHndl)->name->familyName.octetLen =
+        strlen ((*childHndl)->name->familyName.octs);
+
+    childHndl = AsnListAppend (pr.children);
+    *childHndl = Asn1Alloc (sizeof (ChildInformation));
+
+    (*childHndl)->dateOfBirth.octs = "19610621";
+    (*childHndl)->dateOfBirth.octetLen  = strlen ((*childHndl)->dateOfBirth.octs);
+
+    (*childHndl)->name = (Name*) Asn1Alloc (sizeof (Name));
+
+    (*childHndl)->name->givenName.octs = "Lisa";
+    (*childHndl)->name->givenName.octetLen =
+        strlen ((*childHndl)->name->givenName.octs);
+    (*childHndl)->name->initial.octs = "M";
+    (*childHndl)->name->initial.octetLen =
+        strlen ((*childHndl)->name->initial.octs);
+    (*childHndl)->name->familyName.octs = "Smith";
+    (*childHndl)->name->familyName.octetLen =
+        strlen ((*childHndl)->name->familyName.octs);
+
+    SBufInit (&outputBuf,data, dataSize);
+    SBufResetInWriteRvsMode (&outputBuf);
+
+    encodedLen = BEncPersonnelRecord (&outputBuf, &pr);
+
+    /*
+     * after encoding a value ALWAYS check for write error
+     * in the buffer.  The encode routine do not use longjmp
+     * when they enter an error state
+     */
+    if ((encodedLen <= 0) || (SBufWriteError (&outputBuf)))
+    {
+        fprintf (stderr, "failed encoding PersonnelRecord value\n");
+        exit (1);
+    }
+
+    outputFile = fopen ("pr.ber", "w");
+    if (!outputFile)
+    {
+        perror ("fopen:");
+        exit (1);
+    }
+
+    SBufResetInReadMode (&outputBuf);
+    for ( ; encodedLen > 0; encodedLen--)
+        fputc (SBufGetByte (&outputBuf), outputFile);
+
+
+    printf ("Wrote the following BER PersonnelRecord value to pr.ber.\n");
+    printf ("Test it with \"def\" and \"indef\"\n");
+
+    PrintPersonnelRecord (stdout, &pr, 0);
+    printf ("\n");
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c-examples/simple/good-pr.ber.uu snacc-1.3b4/c-examples/simple/good-pr.ber.uu
--- snacc-1.3bbn/c-examples/simple/good-pr.ber.uu	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/simple/good-pr.ber.uu	2005-07-30 16:56:21.235084304 +0000
@@ -0,0 +1,7 @@
+begin 644 good-pr.ber
+M8(&,81`6!$IO:&X6`446!5-M:71HH!`6#E1H92!":6<@0VAE97-E0@,!AI^A
+M"D,(,3DX,C`Q,#2B$F$0%@1-87)Y%@%,%@53;6ET:*-!,1]A$18%2F%M97,6
+M`5(6!5-M:71HH`I#"#$Y-3<P,S$P,1YA$!8$3&ES818!318%4VUI=&B@"D,(
+(,3DV,3`V,C$`
+`
+end
diff -uraN snacc-1.3bbn/c-examples/simple/makefile snacc-1.3b4/c-examples/simple/makefile
--- snacc-1.3bbn/c-examples/simple/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/simple/makefile	1995-07-24 20:46:17.000000000 +0000
@@ -0,0 +1,198 @@
+# file: c-examples/simple/makefile
+#
+# WARNING: this makefile isn't safe for parallel making!
+#
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/simple/makefile,v 1.6 1995/07/24 20:46:17 rj Exp $
+# $Log: makefile,v $
+# Revision 1.6  1995/07/24 20:46:17  rj
+# useful.asn1 renamed to asn-useful.asn1 to accomodate to snacc's new file name generation scheme.
+#
+# `cd && make' instead of `cd; make'.
+#
+# changed `_' to `-' in file names.
+#
+# Revision 1.5  1995/02/20  11:50:49  rj
+# build snacc if it doesn't exist.
+# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
+#
+# Revision 1.4  1995/02/13  15:05:36  rj
+# augment CPPFLAGS, not overwrite.
+# use $(@D) and $(@F) instead of `dirname $@` and `basename $@` (not every system's got the commands).
+# we need the compiler for the dependencies, so make it if it doesn't yet exist.
+#
+# Revision 1.3  1994/08/31  21:42:52  rj
+# rebuild the executables when the c-lib they get linked against is newer.
+# the file good-pr.ber needs to be distributed.
+#
+# Revision 1.2  1994/08/31  10:31:52  rj
+# since .o files get moved, a few more dependencies are needed.
+#
+# Revision 1.1  1994/08/31  08:46:27  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_SRC_DIR	= $(TOP)/asn1specs
+
+ASN1_C_LIB_DIR	= $(TOP)/c-lib
+ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
+MBUF_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1cmbuf.a
+SBUF_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
+EBUF_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1cebuf.a
+
+COMPILERDIR	= $(TOP)/compiler
+SNACC		= $(COMPILERDIR)/snacc
+USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
+SNACCFLAGS	= -u $(USEFUL_TYPES)
+
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) $(BUFFLAG) $(LENFLAG)
+
+ASN1FILES	= $(ASN1_SRC_DIR)/p-rec.asn1
+# generated by snacc from p-rec.asn1:
+ASN1HFILES	= p-rec.h
+ASN1CFILES	= p-rec.c
+
+CFILES = \
+	genber.c	\
+	minbuf-ex.c	\
+	expbuf-ex.c	\
+	sbuf-ex.c
+
+BUFFLAG		= -DUSE_SBUF
+
+DISTFILES = \
+	README		\
+	makefile	\
+	$(CFILES)	\
+	good-pr.ber
+
+#-------------------------------------------------------------------------------
+
+all::		genber minbuf-def minbuf-indef expbuf-def expbuf-indef sbuf-def sbuf-indef
+
+$(ASN1HFILES)	\
+$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
+		$(REASON)
+		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
+
+$(SNACC):
+		cd $(@D) && $(MAKE) $(@F)
+
+min-def-obj	\
+min-indef-obj	\
+exp-def-obj	\
+exp-indef-obj	\
+s-def-obj	\
+s-indef-obj:
+		mkdir $@
+
+min-def-obj/p-rec.o	\
+min-def-obj/minbuf-ex.o:
+		$(REASON)
+		$(MAKE) BUFFLAG=-DUSE_MIN_BUF LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+min-indef-obj/p-rec.o	\
+min-indef-obj/minbuf-ex.o:
+		$(REASON)
+		$(MAKE) BUFFLAG=-DUSE_MIN_BUF LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+exp-def-obj/p-rec.o	\
+exp-def-obj/expbuf-ex.o:
+		$(REASON)
+		$(MAKE) BUFFLAG=-DUSE_EXP_BUF LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+exp-indef-obj/p-rec.o	\
+exp-indef-obj/expbuf-ex.o:
+		$(REASON)
+		$(MAKE) BUFFLAG=-DUSE_EXP_BUF LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+s-def-obj/p-rec.o	\
+s-def-obj/sbuf-ex.o:
+		$(REASON)
+		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+s-indef-obj/p-rec.o	\
+s-indef-obj/sbuf-ex.o:
+		$(REASON)
+		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
+		mv $(@F) $@
+
+genber:		s-def-obj/p-rec.o genber.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ s-def-obj/p-rec.o genber.o $(SBUF_ASN1_LIB) $(LIBS)
+
+minbuf-def: 	min-def-obj/p-rec.o min-def-obj/minbuf-ex.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ min-def-obj/p-rec.o min-def-obj/minbuf-ex.o $(MBUF_ASN1_LIB) $(LIBS)
+
+minbuf-indef:	min-indef-obj/p-rec.o min-indef-obj/minbuf-ex.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ min-indef-obj/p-rec.o min-indef-obj/minbuf-ex.o $(MBUF_ASN1_LIB) $(LIBS)
+
+expbuf-def: 	exp-def-obj/p-rec.o exp-def-obj/expbuf-ex.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ exp-def-obj/p-rec.o exp-def-obj/expbuf-ex.o $(EBUF_ASN1_LIB) $(LIBS)
+
+expbuf-indef:	exp-indef-obj/p-rec.o exp-indef-obj/expbuf-ex.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ exp-indef-obj/p-rec.o exp-indef-obj/expbuf-ex.o $(EBUF_ASN1_LIB) $(LIBS)
+
+sbuf-def: 	s-def-obj/p-rec.o s-def-obj/sbuf-ex.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ s-def-obj/p-rec.o s-def-obj/sbuf-ex.o $(SBUF_ASN1_LIB) $(LIBS)
+
+sbuf-indef:	s-indef-obj/p-rec.o s-indef-obj/sbuf-ex.o
+		$(REASON)
+		$(CC) $(LDFLAGS) -o $@ s-indef-obj/p-rec.o s-indef-obj/sbuf-ex.o $(SBUF_ASN1_LIB) $(LIBS)
+
+genber		\
+sbuf-def	\
+sbuf-indef:	$(SBUF_ASN1_LIB)
+
+minbuf-def	\
+minbuf-indef:	$(MINBUF_ASN1_LIB)
+
+expbuf-def	\
+expbuf-indef:	$(EXPBUF_ASN1_LIB)
+
+.PHONY:	check
+
+check::		minbuf-def minbuf-indef expbuf-def expbuf-indef sbuf-def sbuf-indef
+		for bt in min exp s; do\
+		  $(RM) $$bt-foo.ber $$bt-bar.ber;\
+		  ./$${bt}buf-indef good-pr.ber > $$bt-foo.ber;\
+		  ./$${bt}buf-def $$bt-foo.ber > $$bt-bar.ber;\
+		done
+		@for bt in min exp s; do\
+		  if cmp -s $$bt-bar.ber good-pr.ber; then\
+		    echo "+++ Passed simple encode/decode tests using p-rec.asn1 with $${bt}bufs.";\
+		  else\
+		    echo "--- Failed simple encode/decode tests using p-rec.asn1 with $${bt}bufs.";\
+		  fi;\
+		  $(RM) $$bt-foo.ber $$bt-bar.ber;\
+		done
+
+clean::
+		$(RM) *.o *~ core .emacs*
+		$(RM) expbuf-def expbuf-indef sbuf-indef sbuf-def minbuf-def minbuf-indef genber pr.ber $(ASN1HFILES) $(ASN1CFILES)
+		$(RM) -r *-def-obj *-indef-obj
+		$(RM) *-foo.ber *-bar.ber
+
+depend::	$(SNACC)
+
+include ../../maketail
+
+depend::
+		cp dependencies deps
+		for dir in min-def-obj min-indef-obj exp-def-obj exp-indef-obj s-def-obj s-indef-obj; do\
+		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
+		done
+		mv deps dependencies
diff -uraN snacc-1.3bbn/c-examples/simple/minbuf-ex.c snacc-1.3b4/c-examples/simple/minbuf-ex.c
--- snacc-1.3bbn/c-examples/simple/minbuf-ex.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/simple/minbuf-ex.c	1995-07-24 20:46:59.000000000 +0000
@@ -0,0 +1,162 @@
+/*
+ * c_examples/simple/minbuf_ex.c - an example of how to call C ASN.1-BER
+ *               encoders and decoders generated by snacc
+ *               using the MinBuf buffer.
+ *
+ * AUTHOR: Mike Sample
+ * DATE:   Mar 92
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/c-examples/simple/minbuf-ex.c,v 1.5 1995/07/24 20:46:59 rj Exp $
+ * $Log: minbuf-ex.c,v $
+ * Revision 1.5  1995/07/24 20:46:59  rj
+ * changed `_' to `-' in file names.
+ *
+ * Revision 1.4  1995/02/18  15:12:55  rj
+ * cosmetic changes
+ *
+ * Revision 1.3  1994/09/01  01:02:38  rj
+ * more portable .h file inclusion.
+ *
+ * Revision 1.2  1994/08/31  08:59:36  rj
+ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+ *
+ */
+
+#include "asn-incl.h"
+
+#include <sys/file.h>
+#include <sys/stat.h>
+#if HAVE_FCNTL_H 
+#include <fcntl.h>
+#endif
+#include <stdio.h>
+
+#include "p-rec.h"
+
+
+main PARAMS ((argc, argv),
+    int argc _AND_
+    char *argv[])
+{
+    int fd;
+    char  *buf;
+    char *encBuf;
+    char *encData;
+    int encBufSize;
+    AsnLen encodedLen;
+    AsnLen decodedLen;
+    int     val;
+    PersonnelRecord pr;
+    int      size;
+    char    *origData;
+    struct stat sbuf;
+    jmp_buf env;
+    int  decodeErr;
+    AsnTag tag;
+
+
+    if (argc != 2)
+    {
+        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
+        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
+        fprintf (stderr, "   and re-encodes it to stdout\n");
+        exit (1);
+    }
+
+    fd = open (argv[1], O_RDONLY, 0);
+    if (fd < 0)
+    {
+        perror ("main: fopen");
+        exit (1);
+    }
+
+    if (fstat (fd, &sbuf) < 0)
+    {
+        perror ("main: fstat");
+        exit (1);
+    }
+
+    size = sbuf.st_size;
+    origData = (char*)malloc (size);
+    if (read (fd, origData, size) != size)
+    {
+        perror ("main: read");
+        exit (1);
+    }
+
+    close (fd);
+
+    /* set up min buf  */
+    buf = origData;
+
+    /*
+     * the first argument (512) is the number of bytes to
+     * initially allocate for the decoder to allocate from.
+     * The second argument (512) is the size in bytes to
+     * enlarge the nibble memory by when it fills up
+     */
+    InitNibbleMem (512, 512);
+
+
+    decodedLen = 0;
+    decodeErr = FALSE;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecPersonnelRecord (&buf, &pr, &decodedLen, env);
+    }
+    else
+    {
+        decodeErr = TRUE;
+        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
+    }
+
+    if (decodeErr)
+        exit (1);
+
+    fprintf (stderr, "decodedValue PersonnelRecord ::= ");
+    PrintPersonnelRecord (stderr, &pr, 0);
+    fprintf (stderr, "\n\n");
+
+    /*
+     * setup a new buffer set up for writing.
+     * make sure size is big enough to hold the encoded
+     * value (may be larger than decoded value if encoding
+     * with indef lengths - so add 512 slush bytes)
+     */
+    encBufSize = size + 512;
+    encData = (char*) malloc (encBufSize);
+
+    /*
+     * set 'buffer' up for writing by setting ptr
+     * byte after last byte of the block
+     */
+    encBuf = encData + encBufSize;
+    encodedLen =  BEncPersonnelRecord (&encBuf, &pr);
+
+    /*
+     *  this will never report a write error
+     *  since no error checking done by MinBuf code
+     *  and alawys return false for when read or write errors.
+     */
+    if (MinBufWriteError (&encBuf))
+    {
+        fprintf (stderr, "ERROR - buffer to hold the encoded value was too small\n");
+        exit (1);
+    }
+
+    /*
+     * free all of the decoded value since
+     * it has been encoded into the buffer.
+     * This is much more efficient than freeing
+     * each compontent of the value individually
+     */
+    ResetNibbleMem();
+
+    /*
+     * write encoded value from encBuf
+     * to stdout
+     */
+    fwrite (encBuf, encData + encBufSize - encBuf, 1, stdout);
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c-examples/simple/sbuf-ex.c snacc-1.3b4/c-examples/simple/sbuf-ex.c
--- snacc-1.3bbn/c-examples/simple/sbuf-ex.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/simple/sbuf-ex.c	1995-07-24 20:47:00.000000000 +0000
@@ -0,0 +1,154 @@
+/*
+ * c_examples/simple/sbuf_ex.c - an example of how to call C ASN.1-BER
+ *             encoders and decoders generated by snacc
+ *             using the SBuf buffer.
+ *
+ * AUTHOR: Mike Sample
+ * DATE:   Mar 92
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/c-examples/simple/sbuf-ex.c,v 1.5 1995/07/24 20:47:00 rj Exp $
+ * $Log: sbuf-ex.c,v $
+ * Revision 1.5  1995/07/24 20:47:00  rj
+ * changed `_' to `-' in file names.
+ *
+ * Revision 1.4  1995/02/18  15:12:56  rj
+ * cosmetic changes
+ *
+ * Revision 1.3  1994/09/01  01:02:39  rj
+ * more portable .h file inclusion.
+ *
+ * Revision 1.2  1994/08/31  08:59:37  rj
+ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+ *
+ */
+
+#include "asn-incl.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#if HAVE_FCNTL_H 
+#include <fcntl.h>
+#endif
+#include <stdio.h>
+
+#include "p-rec.h"
+
+main PARAMS ((argc, argv),
+    int argc _AND_
+    char *argv[])
+{
+    int fd;
+    SBuf  buf;
+    SBuf  encBuf;
+    char *encData;
+    AsnLen encodedLen;
+    AsnLen decodedLen;
+    int     val;
+    PersonnelRecord pr;
+    int      size;
+    char    *origData;
+    struct stat sbuf;
+    jmp_buf env;
+    int  decodeErr;
+    AsnTag tag;
+
+    if (argc != 2)
+    {
+        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
+        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
+        fprintf (stderr, "   and re-encodes it to stdout\n");
+        exit (1);
+    }
+
+    fd = open (argv[1], O_RDONLY, 0);
+    if (fd < 0)
+    {
+        perror ("main: fopen");
+        exit (1);
+    }
+
+    if (fstat (fd, &sbuf) < 0)
+    {
+        perror ("main: fstat");
+        exit (1);
+    }
+
+    size = sbuf.st_size;
+    origData = (char*)malloc (size);
+    if (read (fd, origData, size) != size)
+    {
+        perror ("main: read");
+        exit (1);
+    }
+
+    close (fd);
+
+    /*
+     * puts the given data 'origData' of 'size' bytes
+     * into an SBuf and sets the SBuf up for reading
+     * origData from the beginning
+     */
+    SBufInstallData (&buf, origData, size);
+
+    /*
+     * the first argument (512) is the number of bytes to
+     * initially allocate for the decoder to allocate from.
+     * The second argument (512) is the size in bytes to
+     * enlarge the nibble memory by when it fills up
+     */
+    InitNibbleMem (512, 512);
+
+
+    decodedLen = 0;
+    decodeErr = FALSE;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecPersonnelRecord (&buf, &pr, &decodedLen, env);
+    }
+    else
+    {
+        decodeErr = TRUE;
+        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
+    }
+
+    if (decodeErr)
+        exit (1);
+
+    fprintf (stderr, "decodedValue PersonnelRecord ::= ");
+    PrintPersonnelRecord (stderr, &pr, 0);
+    fprintf (stderr, "\n\n");
+
+    /*
+     * setup a new buffer set up for writing.
+     * make sure size is big enough to hold the encoded
+     * value (may be larger than decoded value if encoding
+     * with indef lengths - so add 512 slush bytes)
+     */
+    encData = (char*) malloc (size + 512);
+    SBufInit (&encBuf, encData, size + 512);
+    SBufResetInWriteRvsMode (&encBuf);
+
+    encodedLen =  BEncPersonnelRecord (&encBuf, &pr);
+
+    if (SBufWriteError (&encBuf))
+    {
+        fprintf (stderr, "ERROR - buffer to hold the encoded value was too small\n");
+        exit (1);
+    }
+
+    /*
+     * free all of the decoded value since
+     * it has been encoded into the buffer.
+     * This is much more efficient than freeing
+     * each compontent of the value individually
+     */
+    ResetNibbleMem();
+
+    /*
+     * write encoded value from encBuf
+     * to stdout
+     */
+    fwrite (SBufDataPtr (&encBuf), SBufDataLen (&encBuf), 1, stdout);
+
+    return 0;
+}
diff -uraN snacc-1.3bbn/c-examples/snmp/README snacc-1.3b4/c-examples/snmp/README
--- snacc-1.3bbn/c-examples/snmp/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/snmp/README	1995-07-27 09:58:31.000000000 +0000
@@ -0,0 +1,118 @@
+(RCS control information is at the end of this file.)
+
+
+C SNMP Example - Mike Sample Mar 92
+-----------------------------------
+
+This example illustrates a few more features of the compiler than the
+simple example.  It also shows some deficiencies.  No executable
+programs are generated by the makefile, it only generates the snmp
+code and compiles it without linking.
+
+This directory contains 2 files:
+        README
+        makefile
+
+Snacc generates source from the following ASN.1 files:
+        snacc/asn1specs/rfc1155_smi.asn1
+        snacc/asn1specs/rfc1157_snmp.asn1
+        snacc/asn1specs/rfc1213_mib2.asn1
+
+multi-module compilation
+   The IMPORT/EXPORT mechanisms of ASN.1 '88 are supported so you don't
+   have to dump all of the ASN.1 definitions into a single file
+   The order of the ASN.1 file arguments is the order that they
+   are included in the generated source files.  For example:
+
+   %1 snacc rfc1155-smi.asn1 rfc1157-snmp.asn1 rfc1213-mib2.asn1
+
+   causes the order in which hdr files are included  in rfc1213-mib.c
+   to be:
+
+   #include "asn-incl.h"
+   #include "rfc1155-smi.h"
+   #include "rfc1157-snmp.h"
+   #include "rfc1213-mib2.h"
+
+
+    Currently, snacc assumes that each ASN.1 file given on the command
+    line depends on all of the others on the command line.  There is
+    no attempt to compute the dependencies via the import lists alone.
+
+SNMP OBJECT-TYPE macro parsing / ANY type hash table
+   The SNMP OBJECT-TYPE macro is parsed.   This results in the
+   type in the "SYNTAX" part of the macro is put into
+   the ANY type hash table using the  OBJECT-TYPE macro's value as the
+   hash key.  Also if the type in the SYNTAX field is not defined
+   outsided of the macro (could be different tagging etc), a proper
+   type definition is generated for it.  If you want to change the way
+   the macro is handled, modify the corresponding routine in "do_macros.c".
+
+value definitions
+   The OBJECT IDENTIFIER values are turned into statically initialized
+   C values and included in the generated source and include file.  This
+   is also done for INTEGER and BOOLEAN values.  More complex values
+   are ignored by the compiler at the moment. (modify parse_vals.c if
+   you want to improve this)
+
+
+-P option of snacc is demonstrated
+   The ASN.1 for the parsed modules is generated from the internal data
+   structure.  This can be useful for making sure the compiler is
+   handling your ASN.1 files correctly.  It is also useful to see how
+   the types are modified and sorted to simplify code generation.
+   (see the snacc.output file after typeing "make")
+
+Deficiencies
+   A deficiency in parsing large integers is shown when parsing the
+   following rfc 1155 types:
+
+                  Counter ::=
+                      [APPLICATION 1]
+                          IMPLICIT INTEGER (0..4294967295)
+
+                  Gauge ::=
+                      [APPLICATION 2]
+                          IMPLICIT INTEGER (0..4294967295)
+
+                  TimeTicks ::=
+                      [APPLICATION 3]
+                          IMPLICIT INTEGER (0..4294967295)
+
+Due the size of a C long int the above ASN.1 is represented internally as:
+
+Counter ::= [APPLICATION 1] IMPLICIT INTEGER (0..-1)
+
+Gauge ::= [APPLICATION 2] IMPLICIT INTEGER (0..-1)
+
+TimeTicks ::= [APPLICATION 3] IMPLICIT INTEGER (0..-1)
+
+The ASN.1 library contains routines for encoding/decoding unsigned
+long integers but you must hand code the cases where it is used - the
+compiler never generates code that calls them.
+
+Note also that the produced code for the SNMP ASN.1 must be modified
+to correclty handle the "Opaque" data type.  SNMP does not use the ANY
+DEFINED BY type in an effort to simplify things.  Instead an OCTET
+STRING is used to hold and encoded value whose type is defined by an
+OBJECT IDENTIFIER.  With some simple modifications you can use the
+snacc AsnAnyDefinedBy type instead of the OCTET STRING to achieve
+the desired results.
+
+This should underline the danger of blindly trusting the compiler to
+do the right thing for protocols such as SNMP or X.500 where the type
+of an encoded value depends on a mechanism outside of ASN.1 or the ANY
+type (ANY DEFINED BY types should work automatically).
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/snmp/README,v 1.3 1995/07/27 09:58:31 rj Exp $
+# $Log: README,v $
+# Revision 1.3  1995/07/27 09:58:31  rj
+# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
+#
+# Revision 1.2  1995/07/24  20:47:39  rj
+# changed `_' to `-' in file names.
+#
+# Revision 1.1  1994/08/31  08:46:33  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c-examples/snmp/makefile snacc-1.3b4/c-examples/snmp/makefile
--- snacc-1.3bbn/c-examples/snmp/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/snmp/makefile	1995-07-27 09:57:38.000000000 +0000
@@ -0,0 +1,91 @@
+# c-examples/snmp/makefile
+#
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/snmp/makefile,v 1.6 1995/07/27 09:57:38 rj Exp $
+# $Log: makefile,v $
+# Revision 1.6  1995/07/27 09:57:38  rj
+# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
+#
+# Revision 1.5  1995/07/24  20:48:27  rj
+# `cd && make' instead of `cd; make'.
+#
+# changed `_' to `-' in file names.
+#
+# Revision 1.4  1995/02/20  11:52:11  rj
+# build snacc if it doesn't exist.
+#
+# Revision 1.3  1995/02/13  15:05:48  rj
+# augment CPPFLAGS, not overwrite.
+# we need the compiler for the dependencies, so make it if it doesn't yet exist.
+#
+# Revision 1.2  1994/08/31  23:25:46  rj
+# print a less irritating usage.
+#
+# Revision 1.1  1994/08/31  08:46:34  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_SPEC_DIR	= $(TOP)/asn1specs
+
+ASN1_C_LIB_DIR	= $(TOP)/c-lib
+ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
+ASN1_C_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
+
+COMPILERDIR	= $(TOP)/compiler
+SNACC		= $(COMPILERDIR)/snacc
+
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_SBUF
+
+ASN1FILES = \
+	$(ASN1_SPEC_DIR)/rfc1155-smi.asn1	\
+	$(ASN1_SPEC_DIR)/rfc1157-snmp.asn1	\
+	$(ASN1_SPEC_DIR)/rfc1213-mib2.asn1
+
+ASN1HFILES = \
+	rfc1155-smi.h	\
+	rfc1213-mib2.h	\
+	rfc1157-snmp.h
+
+ASN1CFILES = \
+	rfc1155-smi.c	\
+	rfc1213-mib2.c	\
+	rfc1157-snmp.c
+
+DISTFILES = \
+	README		\
+	makefile	\
+
+#-------------------------------------------------------------------------------
+
+default::	warning
+
+warning::
+		@echo ''
+		@echo 'read the README and enter `$(MAKE) fail` to test for yourself'
+		@echo ''
+
+fail::		$(ASN1HFILES) $(ASN1CFILES)
+		$(CC) $(CPPFLAGS) $(CFLAGS) -c $(ASN1CFILES)
+
+$(ASN1HFILES)	\
+$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
+		$(REASON)
+		$(SNACC) -P $(ASN1FILES) > snacc.output~
+		mv snacc.output~ snacc.output
+
+$(SNACC):
+		cd $(@D) && $(MAKE) $(@F)
+
+check::
+		@echo "the purpose of this directories' contents is to show deficiencies."
+		@echo "if you want to exercise 'em, make the phony target "'`'"fail'"
+
+clean::
+		$(RM) *.o *~ .emacs* core $(ASN1HFILES) $(ASN1CFILES) snacc.output
+
+depend::	$(SNACC)
+
+include ../../maketail
diff -uraN snacc-1.3bbn/c-examples/test-lib/README snacc-1.3b4/c-examples/test-lib/README
--- snacc-1.3bbn/c-examples/test-lib/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/test-lib/README	1997-02-16 20:26:19.000000000 +0000
@@ -0,0 +1,37 @@
+(RCS control information is at the end of this file.)
+
+
+C test_lib README
+-----------------
+
+This directory should have 3 files:
+        README - this file
+        makefile
+        test_lib.c
+
+Type "make" to compile test_lib.
+
+test_lib tests each encode and decode routine in the C ASN.1
+runtime library. Errors will be reported.
+
+test_lib should be run for each machine architecture you install snacc on.
+If you modify the library routines you should run test_lib again.
+
+The general testing methodology is:
+        1. test the buffer routines
+        2. test tags
+        3. test lengths
+        4. test each libarary type.
+
+For each type, a range of values is encoded and then decoded
+and and compared with the original value.
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/test-lib/README,v 1.2 1997/02/16 20:26:19 rj Exp $
+# $Log: README,v $
+# Revision 1.2  1997/02/16 20:26:19  rj
+# check-in of a few cosmetic changes
+#
+# Revision 1.1  1994/08/31  08:46:36  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
diff -uraN snacc-1.3bbn/c-examples/test-lib/makefile snacc-1.3b4/c-examples/test-lib/makefile
--- snacc-1.3bbn/c-examples/test-lib/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/test-lib/makefile	1995-07-24 20:50:11.000000000 +0000
@@ -0,0 +1,50 @@
+# c-examples/test-lib/makefile
+#
+# $Header: /usr/app/odstb/CVS/snacc/c-examples/test-lib/makefile,v 1.4 1995/07/24 20:50:11 rj Exp $
+# $Log: makefile,v $
+# Revision 1.4  1995/07/24 20:50:11  rj
+# changed `_' to `-' in file names.
+#
+# Revision 1.3  1995/02/13  15:05:59  rj
+# augment CPPFLAGS, not overwrite.
+#
+# Revision 1.2  1994/08/31  21:43:20  rj
+# rebuild the executables when the c-lib is newer.
+#
+# Revision 1.1  1994/08/31  08:46:37  rj
+# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+#
+
+include ../../makehead
+
+TOP		= ../..
+
+ASN1_C_LIB_DIR	= $(TOP)/c-lib
+ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
+ASN1_C_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
+
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_SBUF
+
+LDLIBS		= $(ASN1_C_LIB) $(LIBS)
+
+CFILES = \
+	test-lib.c
+
+DISTFILES = \
+	README		\
+	makefile	\
+	$(CFILES)
+
+#-------------------------------------------------------------------------------
+
+default::	check
+
+check::		test-lib
+		./test-lib
+
+test-lib:	$(ASN1_C_LIB)
+
+clean::
+		$(RM) *.o *~ .emacs* test-lib core
+
+include ../../maketail
diff -uraN snacc-1.3bbn/c-examples/test-lib/test-lib.c snacc-1.3b4/c-examples/test-lib/test-lib.c
--- snacc-1.3bbn/c-examples/test-lib/test-lib.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/c-examples/test-lib/test-lib.c	1995-07-24 20:50:34.000000000 +0000
@@ -0,0 +1,935 @@
+/*
+ * c_examples/test_lib/test_lib.c
+ *
+ * uses SBufs for buffers
+ *
+ * MS 92
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/c-examples/test-lib/test-lib.c,v 1.5 1995/07/24 20:50:34 rj Exp $
+ * $Log: test-lib.c,v $
+ * Revision 1.5  1995/07/24 20:50:34  rj
+ * ``#error "..."'' instead of ``#error ...''.
+ *
+ * changed `_' to `-' in file names.
+ *
+ * Revision 1.4  1995/02/18  16:17:44  rj
+ * utilize either isinf(3) or finite(3), whatever happens to be present.
+ *
+ * Revision 1.3  1994/08/31  23:48:45  rj
+ * more portable .h file inclusion.
+ *
+ * Revision 1.2  1994/08/31  08:59:39  rj
+ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
+ *
+ */
+
+#include <stdio.h>
+
+#include "asn-incl.h"
+
+int TestAsnBuffers();
+int TestAsnTag();
+int TestAsnLen();
+int TestAsnBool();
+int TestAsnInt();
+int TestAsnReal();
+int TestAsnOcts();
+int TestAsnBits();
+int TestAsnOid();
+int TestAsnList();
+
+int bufSize = 256;
+
+int
+main()
+{
+    int isErr = FALSE;
+
+    /* set up the PLUS and MINUS INFINITY globals */
+    InitAsnInfinity();
+
+    /* needed for OCTET STRING, BIT STRING and OBJECT IDENTIFIER decoding */
+    InitNibbleMem (256, 256);
+
+    if (!TestAsnBuffers())
+    {
+        fprintf (stdout, "Failed buffer tests, no point in proceeding ... bye!\n");
+        return 1;
+    }
+
+
+    if (!TestAsnTag())
+    {
+        fprintf (stdout, "Failed Tag test.\n" );
+        isErr = TRUE;
+    }
+
+    if (!TestAsnLen())
+    {
+        fprintf (stdout, "Failed Length test.\n" );
+        isErr = TRUE;
+    }
+
+    if (!TestAsnBool())
+    {
+        fprintf (stdout, "Failed BOOLEAN test.\n" );
+        isErr = TRUE;
+    }
+
+
+    if (!TestAsnInt())
+    {
+        fprintf (stdout, "Failed INTEGER test.\n" );
+        isErr = TRUE;
+    }
+
+    if (!TestAsnOcts())
+    {
+        fprintf (stdout, "Failed OCTET STRING test.\n" );
+        isErr = TRUE;
+    }
+
+
+    if (!TestAsnBits())
+    {
+        fprintf (stdout, "Failed BIT STRING test.\n" );
+        isErr = TRUE;
+    }
+
+
+    if (!TestAsnOid())
+    {
+        fprintf (stdout, "Failed OBJECT IDENTIFIER test.\n" );
+        isErr = TRUE;
+    }
+
+
+    if (!TestAsnReal())
+    {
+        fprintf (stdout, "Failed REAL test.\n" );
+        isErr = TRUE;
+    }
+
+
+
+    if (isErr)
+    {
+        fprintf (stdout, "There are errors in the primitive type encoding/decoding\n" );
+        fprintf (stdout, "library for this architecture.  Time for gdb...\n" );
+    }
+    else
+    {
+        fprintf (stdout, "The primitive type encoding/decoding library passed simple tests.\n");
+        fprintf (stdout, "It should be safe to use...\n" );
+    }
+
+    return isErr;
+}
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnBuffers()
+{
+    int i,j;
+    int noErr = TRUE;
+    SBuf  b;
+    char bufData[256];
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+    SBufResetInWriteRvsMode (&b);
+
+    /*
+     * write whole range of byte (0..255)
+     * remember, write works in reverse
+     */
+    for (i = 0; i < 256; i++)
+        BufPutByteRvs (&b,i);
+
+    if (BufWriteError (&b))
+    {
+        fprintf (stdout, "Error writing to buffer.\n" );
+        noErr = FALSE;
+    }
+
+    /* read in values & verify */
+    SBufResetInReadMode (&b);
+    for (i = 255; i >= 0; i--)
+        if (BufGetByte (&b) != i)
+        {
+            fprintf (stdout, "Error verifying data written to buffer.\n" );
+            noErr = FALSE;
+        }
+
+    if (BufReadError (&b))
+    {
+        fprintf (stdout, "Error reading from buffer.\n" );
+        noErr = FALSE;
+    }
+
+
+    /* now make sure errors are detected */
+    SBufResetInWriteRvsMode (&b);
+
+    for (i = 0; i < 257; i++) /*  write past end of buffer */
+        BufPutByteRvs (&b,0);
+
+    if (!BufWriteError (&b))
+    {
+        fprintf (stdout, "Buffers failed to report buffer write overflow.\n" );
+        noErr = FALSE;
+    }
+
+
+    SBufResetInReadMode (&b);
+    for (i = 256; i >= 0; i--)  /*  read past end of buffer  */
+        BufGetByte (&b);
+
+    if (!BufReadError (&b))
+    {
+        fprintf (stdout, "Buffers failed to report buffer read overflow.\n" );
+        noErr = FALSE;
+    }
+
+    return noErr;
+}  /* TestAsnBuffers */
+
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnTag()
+{
+    AsnTag aTag1;
+    AsnTag aTag2;
+    int i, j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+    BER_CLASS class;
+    BER_FORM form;
+    BER_UNIV_CODE code;
+
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+
+
+    /* encode a true value and verify */
+    class = UNIV;
+    form = PRIM;
+    code = INTEGER_TAG_CODE;
+    aTag1 = MAKE_TAG_ID (class, form, code);
+
+    for (i = 0; i < 2; i++)
+    {
+        SBufResetInWriteRvsMode (&b);
+        len1 = BEncTag1 (&b, class, form, code);
+
+        if (BufWriteError (&b))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error encoding a Tag.\n" );
+        }
+
+        SBufResetInReadMode (&b);
+
+        aTag2 = 0;
+
+        /* make sure no decode errors and that it decodes to same tag */
+        len2 = 0;
+        if ((val = setjmp (env)) == 0)
+        {
+            aTag2 = BDecTag (&b, &len2, env);
+        }
+        else
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error decoding a Tag - error number %d\n", val);
+        }
+        if (noErr && ((aTag2 != aTag1) || (len1 != len2)))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error decoded Tag does not match encoded Tag.\n" );
+        }
+        /* set a new test tag value */
+        class = CNTX;
+        form = CONS;
+        code = 29;
+        aTag1 = MAKE_TAG_ID (class, form, code);
+    }
+    return noErr;
+}  /* TestAsnTag */
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnLen()
+{
+    AsnLen aLen1;
+    AsnLen aLen2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+
+
+    /* encode a true value and verify */
+    aLen1 = 99999;
+    for (i = 0; i < 2; i++)
+    {
+        SBufResetInWriteRvsMode (&b);
+        len1 = BEncDefLen (&b, aLen1);
+
+        if (BufWriteError (&b))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error encoding Length.\n" );
+        }
+
+        SBufResetInReadMode (&b);
+
+        aLen2 = 0;
+
+        /* make sure no decode errors and that it decodes to true */
+        len2 = 0;
+        if ((val = setjmp (env)) == 0)
+        {
+            aLen2 = BDecLen (&b, &len2, env);
+        }
+        else
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error decoding Length - error number %d\n", val);
+        }
+
+
+        if (noErr && ((aLen2 != aLen1) || (len1 != len2)))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error - decoded lenght does not match encoded length\n");
+        }
+        aLen1 = 2;
+    }
+
+
+    /* test indef len */
+    SBufResetInWriteRvsMode (&b);
+    len1 = BEncIndefLen (&b);
+
+    if (BufWriteError (&b))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error encoding indefinite Length.\n" );
+    }
+
+    SBufResetInReadMode (&b);
+
+    aLen2 = 0;
+
+    /* make sure no decode errors */
+    len2 = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        aLen2 = BDecLen (&b, &len2, env);
+    }
+    else
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding Length - error number %d\n", val);
+    }
+
+
+    if (noErr && ((aLen2 != INDEFINITE_LEN) || (len1 != len2)))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error - decoded length does not match encoded length\n");
+    }
+
+    /* test EOC */
+    SBufResetInWriteRvsMode (&b);
+    len1 = BEncEoc (&b);
+
+    if (BufWriteError (&b))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error encoding indefinite Length.\n" );
+    }
+
+    SBufResetInReadMode (&b);
+
+    aLen2 = 0;
+
+    /* make sure no decode errors */
+    len2 = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecEoc (&b, &len2, env);
+    }
+    else
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding Length - error number %d\n", val);
+    }
+
+
+    if (noErr && (len1 != len2))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error - decoded EOC length error.\n");
+    }
+
+    return noErr;
+}  /* TestAsnLen */
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnBool()
+{
+    AsnBool aBool1;
+    AsnBool aBool2;
+    int j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+    SBufResetInWriteRvsMode (&b);
+
+    /* encode a true value and verify */
+    aBool1 = TRUE;
+    len1 = BEncAsnBoolContent (&b, &aBool1);
+
+    if (BufWriteError (&b))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error encoding TRUE BOOLEAN value.\n" );
+    }
+
+    SBufResetInReadMode (&b);
+
+    aBool2 = FALSE; /* set to opposite of expected value */
+
+    /* make sure no decode errors and that it decodes to true */
+    len2 = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecAsnBoolContent (&b, tag, len1, &aBool2, &len2, env);
+    }
+    else
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding a BOOLEAN - error number %d\n", val);
+    }
+
+
+    if (noErr && ((aBool2 != aBool1) || (len1 != len2)))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding TRUE BOOLEAN value.\n" );
+    }
+
+    /* now encode a false value and verify */
+    SBufResetInWriteRvsMode (&b);
+    aBool1 = FALSE;
+
+    len1 = BEncAsnBoolContent (&b, &aBool1);
+    if (BufWriteError (&b))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error encoding FALSE BOOLEAN value.\n" );
+    }
+
+    SBufResetInReadMode (&b);
+
+    aBool2 = TRUE; /* set to opposite of expected value */
+
+    /* make sure no decode errors and that it decodes to true */
+    len2 = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecAsnBoolContent (&b, tag, len1, &aBool2, &len2, env);
+    }
+    else
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding a BOOLEAN - error number %d\n", val);
+    }
+
+
+    if (noErr && ((aBool2 != aBool1) || (len1 != len2)))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding TRUE BOOLEAN value.\n" );
+    }
+
+    /* make sure no decode errors and that it decodes to false */
+
+    return noErr;
+}  /* TestAsnBool */
+
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnInt()
+{
+    AsnInt a1;
+    AsnInt a2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+    int sign;
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+
+    /*
+     * Encode a range of integers: negative & positive in
+     * the 1 to sizeof (AsnInt) range
+     */
+    sign = 1;
+    for (j = 0; j < 2; j++)
+    {
+        for (i = 0; i < sizeof (AsnInt); i++)
+        {
+            SBufResetInWriteRvsMode (&b);
+
+            a1 = sign * (17 << (i * 8)); /* 17 is a random choice :) */
+            len1 = BEncAsnIntContent (&b, &a1);
+            if (BufWriteError (&b))
+            {
+                noErr = FALSE;
+                fprintf (stdout, "Error encoding INTEGER value %d.\n", a1 );
+            }
+
+            SBufResetInReadMode (&b);
+
+            /* make sure no decode errors and that it decodes to true */
+            len2 = 0;
+            if ((val = setjmp (env)) == 0)
+            {
+                BDecAsnIntContent (&b, tag, len1, &a2, &len2, env);
+            }
+            else
+            {
+                noErr = FALSE;
+                fprintf (stdout, "Error decoding a INTEGER - error number %d\n", val);
+            }
+
+            if (noErr && ((a2 != a1) || (len1 != len2)))
+            {
+                noErr = FALSE;
+                fprintf (stdout, "Error decoding INTEGER value %d.\n", a1 );
+            }
+        }
+        sign = -1;
+    }
+
+    return noErr;
+
+}  /* TestAsnInt */
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnOcts()
+{
+    AsnOcts a1;
+    AsnOcts a2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+
+    a1.octs = "Hello Gumby";
+    a1.octetLen = strlen (a1.octs);
+
+    /*
+     * octet string decoder needs to know tag form
+     * (snacc always encodes octet strings as primitives)
+     */
+    tag = MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE);
+
+    for (j = 0; j < 2; j++)
+    {
+        SBufResetInWriteRvsMode (&b);
+
+        len1 = BEncAsnOctsContent (&b, &a1);
+        if (BufWriteError (&b))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error encoding OCTET STRING value \"%s\".\n", a1.octs );
+        }
+        SBufResetInReadMode (&b);
+
+        /* make sure no decode errors and that it decodes to true */
+        len2 = 0;
+        if ((val = setjmp (env)) == 0)
+        {
+            BDecAsnOctsContent (&b, tag, len1, &a2, &len2, env);
+        }
+        else
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error decoding an OCTET STRING - error number %d\n", val);
+        }
+
+        if (noErr && (!AsnOctsEquiv (&a2,&a1) || (len1 != len2)))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error decoding OCTET STRING value %s.\n", a1.octs );
+        }
+        a1.octs = ""; /* test empty string */
+        a1.octetLen = strlen (a1.octs);
+    }
+
+    ResetNibbleMem();
+    return noErr;
+
+}  /* TestAsnOcts */
+
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnBits()
+{
+    AsnBits a1;
+    AsnBits a2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+    short bitsToSet[35];
+
+    /*
+     * init bitsToSet - old compilers don't support automatic init
+     * of aggregate types.
+     */
+    bitsToSet[0] = 0;
+    bitsToSet[1] = 1;
+    bitsToSet[2] = 0;
+    bitsToSet[3] = 0;
+    bitsToSet[4] = 1;
+    bitsToSet[5] = 1;
+    bitsToSet[6] = 0;
+    bitsToSet[7] = 1;
+    bitsToSet[8] = 0;
+    bitsToSet[9] = 1;
+    bitsToSet[10] = 0;
+    bitsToSet[11] = 0;
+    bitsToSet[12] = 1;
+    bitsToSet[13] = 1;
+    bitsToSet[14] = 0;
+    bitsToSet[15] = 1;
+    bitsToSet[16] = 0;
+    bitsToSet[17] = 1;
+    bitsToSet[18] = 0;
+    bitsToSet[19] = 0;
+    bitsToSet[20] = 1;
+    bitsToSet[21] = 1;
+    bitsToSet[22] = 0;
+    bitsToSet[23] = 1;
+    bitsToSet[24] = 0;
+    bitsToSet[25] = 1;
+    bitsToSet[26] = 0;
+    bitsToSet[27] = 1;
+    bitsToSet[28] = 1;
+    bitsToSet[29] = 0;
+    bitsToSet[30] = 1;
+    bitsToSet[31] = 1;
+    bitsToSet[32] = 0;
+    bitsToSet[33] = 1;
+    bitsToSet[34] = 0;
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+
+    /* initialize bit string */
+    a1.bits = Asn1Alloc (5);
+    a1.bitLen = 35;
+    for (i = 0; i < 35; i++)
+    {
+        if (bitsToSet[i])
+            SetAsnBit (&a1, i);
+        else
+            ClrAsnBit (&a1, i);
+    }
+
+    /*
+     * bit string decoder needs to know tag form
+     * (snacc always encodes bit strings as primitives)
+     */
+    tag = MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE);
+
+    SBufResetInWriteRvsMode (&b);
+
+    len1 = BEncAsnBitsContent (&b, &a1);
+    if (BufWriteError (&b))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error encoding BIT STRING value ");
+        PrintAsnBits (stdout, &a1, 0);
+        fprintf (stdout, "\n");
+    }
+    SBufResetInReadMode (&b);
+
+    /* make sure no decode errors and that it decodes to true */
+    len2 = 0;
+    if ((val = setjmp (env)) == 0)
+    {
+        BDecAsnBitsContent (&b, tag, len1, &a2, &len2, env);
+    }
+    else
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding an BIT STRING - error number %d\n", val);
+    }
+
+    if (noErr && (!AsnBitsEquiv (&a2,&a1) || (len1 != len2)))
+    {
+        noErr = FALSE;
+        fprintf (stdout, "Error decoding BIT STRING value ");
+        PrintAsnBits (stdout, &a1, 0);
+        fprintf (stdout, "\n");
+    }
+    ResetNibbleMem();
+    return noErr;
+
+}  /* TestAsnBits */
+
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnOid()
+{
+    AsnOid a1;
+    AsnOid a2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+
+    /*  mib-2 oid  { iso 3 6 1 2 1 }*/
+     a1.octetLen = 5;
+     a1.octs = "\53\6\1\2\1";
+
+
+    for (j = 0; j < 2; j++)
+    {
+        SBufResetInWriteRvsMode (&b);
+
+        len1 = BEncAsnOidContent (&b, &a1);
+        if (BufWriteError (&b))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error encoding OCTET STRING value \"%s\".\n", a1.octs );
+        }
+        SBufResetInReadMode (&b);
+
+        /* make sure no decode errors and that it decodes to true */
+        len2 = 0;
+        if ((val = setjmp (env)) == 0)
+        {
+            BDecAsnOidContent (&b, tag, len1, &a2, &len2, env);
+        }
+        else
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error decoding an OCTET STRING - error number %d\n", val);
+        }
+
+        if (noErr && (!AsnOidsEquiv (&a2,&a1) || (len1 != len2)))
+        {
+            noErr = FALSE;
+            fprintf (stdout, "Error decoding OCTET STRING value %s.\n", a1.octs );
+        }
+        /*  system  { mib-2 1 }*/
+        a1.octs = "\53\6\1\2\1\1";
+        a1.octetLen = 6;
+    }
+    ResetNibbleMem();
+    return noErr;
+
+}  /* TestAsnOid */
+
+/*
+ * returns TRUE if passes encode/decode tests
+ */
+int
+TestAsnReal()
+{
+    AsnReal a1[5];
+    AsnReal a2;
+    int i,j;
+    AsnLen len1;
+    AsnLen len2;
+    AsnTag tag;
+    int noErr = TRUE;
+    int elmtErr = FALSE;
+    ENV_TYPE env;
+    SBuf  b;
+    char bufData[256];
+    long int val;
+    int sign;
+    AsnReal inf;
+    unsigned char *c;
+
+
+    /*
+     * if you do not have the ieee_functions in your math lib,
+     * this will not link.  Comment it out and cross you fingers.
+     * (or check/set the +/-infinity values for you architecture)
+     */
+#if HAVE_ISINF
+    if (!isinf (PLUS_INFINITY) || !isinf (MINUS_INFINITY))
+#else
+#if HAVE_FINITE
+    if (finite (PLUS_INFINITY) || finite (MINUS_INFINITY))
+#else
+  #error "oops: you've got neither isinf(3) nor finite(3)?!"
+#endif
+#endif
+    {
+        fprintf (stdout, "WARNING: PLUS_INFINITY and MINUS_INFINITY in asn_real.c are not\n");
+        fprintf (stdout, "correct for this architecture.  Modify the InitAsnInfinity() Routine.\n");
+    }
+
+    /*
+     * init test value array.
+     * some old compilers don't support automatic init of aggregate types
+     * like:
+     * AsnReal a1[] = { 0.0, 0.8, -22.484848, PLUS_INFINITY, MINUS_INFINITY};
+     */
+    a1[0] = 0.0;
+    a1[1] = 0.8;
+    a1[2] = -22.484848;
+    a1[3] = PLUS_INFINITY;
+    a1[4] = MINUS_INFINITY;
+
+    /* initialize buffer */
+    SBufInit (&b, bufData, 256);
+
+    /*
+     * Encode a range of integers: negative & positive in
+     * the 1 to sizeof (AsnInt) range
+     */
+    for (i = 0; i < 5; i++)
+    {
+        elmtErr = FALSE;
+        SBufResetInWriteRvsMode (&b);
+
+        len1 = BEncAsnRealContent (&b, &a1[i]);
+        if (BufWriteError (&b))
+        {
+            elmtErr = TRUE;
+            fprintf (stdout, "Error encoding REAL value ");
+            PrintAsnReal (stdout,&a1[i],0);
+            fprintf (stdout, ".\n");
+        }
+
+        SBufResetInReadMode (&b);
+
+        /* make sure no decode errors and that it decodes to true */
+        len2 = 0;
+        if ((val = setjmp (env)) == 0)
+        {
+            BDecAsnRealContent (&b, tag, len1, &a2, &len2, env);
+        }
+        else
+        {
+            elmtErr = TRUE;
+            fprintf (stdout, "Error decoding a REAL - error number %d\n", val);
+        }
+
+        /* testing reals for equality is sketchy */
+        if (!elmtErr && ((a2 != a1[i]) || (len1 != len2)))
+        {
+
+            elmtErr = TRUE;
+            fprintf (stdout, "Error decoding REAL value ");
+            PrintAsnReal (stdout, &a1[i], 0);
+            fprintf (stdout, ".\n");
+
+            if (len1 == len2)  /* therefore a2 != a1[i] */
+            {
+                fprintf (stdout, "The value decoded was ");
+                PrintAsnReal (stdout, &a2, 0);
+                fprintf (stdout, ".\n");
+            }
+            else
+                fprintf (stdout, "The encoded and decoded length disagree.\n");
+        }
+        if (elmtErr)
+            noErr = FALSE;
+    }
+
+
+    return noErr;
+
+}  /* TestAsnReal */
diff -uraN snacc-1.3bbn/tbl-example/README snacc-1.3b4/tbl-example/README
--- snacc-1.3bbn/tbl-example/README	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/tbl-example/README	1997-02-15 19:33:24.000000000 +0000
@@ -0,0 +1,83 @@
+(RCS control information is at the end of this file.)
+
+
+Table encoder/decoder example README - MS 93
+------------------------------------
+
+This directory contains an example that shows:
+
+   1. the process of creating and using tables.
+   2. examples of decoding, printing, and encoding.
+
+
+To dive right in just type "make" in this directory.  That will
+create the "example" executable (you should have previously installed
+the snacc and mkchdr progs and the table library).
+
+Then type:
+
+ make check
+
+and see what happens. Look in example.c and makefile to see how things
+work.
+
+
+
+Questions and Answers
+---------------------
+
+Q. What is a table? (also refered to a type table or type tree)
+
+A. A table is simply a data structure that holds a description of
+   the types from an ASN.1 module.  This table can then be used
+   by a number of "generic" routines to do ASN.1 related (BER
+   encoding/decoding) or other useful things such as printing
+   values, freeing values and whatever else you can dream up.
+
+
+Q. How do I create a table from my ASN.1 source files?
+
+A. Run snacc with the -T option, e.g.:
+
+     snacc -T mytbls.tt myMod1.asn1 myMod2.asn1
+
+   the above command will create the "mytbls.tt" file that
+   holds the descriptions of the ASN.1 types in the "myMod1.asn1"
+   and "myMod2.asn1" files. (look in the makefile in this directory)
+
+
+Q. Why is there only a C interface to tables?
+
+A. Time. Tables drivers create/read/free these types
+   without having seen a typedef for them.  The C implementation
+   uses some assumptions about how structures etc. are allocated
+   and accessed.  With C++ this is much more difficult.  It can
+   be done but required more time than I had.
+
+
+Q. Ok, tables sound great, what's the catch?
+
+A. Well,
+
+   1. table driven encoding and decoding is something like
+      4 times slower than the C or C++ version.
+      (but tables are *way* smaller than the .o's for the compiled approach)
+   2. the ANY DEFINED BY stuff is not supported at all.
+   3. subtype information is not included in the tables (time crunch again)
+      (PER encoders/decoders will need the subtype info)
+   4. Values from the ASN.1 source are not included in the table.
+
+   If you have the time and skills, you can fix 2, 3 and 4.  1 is harder.
+
+
+
+Q.  Tell me more.
+
+A.  Look at the manual. (in .../doc/)
+
+#-------------------------------------------------------------------------------
+# $Header: /usr/app/odstb/CVS/snacc/tbl-example/README,v 1.1 1997/02/15 19:33:24 rj Exp $
+# $Log: README,v $
+# Revision 1.1  1997/02/15 19:33:24  rj
+# first check-in
+#
diff -uraN snacc-1.3bbn/tbl-example/example.c snacc-1.3b4/tbl-example/example.c
--- snacc-1.3bbn/tbl-example/example.c	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/tbl-example/example.c	1997-02-15 19:33:26.000000000 +0000
@@ -0,0 +1,174 @@
+/*
+ * file: .../tbl-example/example.c - decodes and prints a given BER
+ * PersonnelRecord value and re-encodes it to the file
+ * "p-rec.out.ber".  This example would be similar to your user code in
+ * that you run "mkchdr" to build a nicely named description of data
+ * structure (PersonnelRecord in this case).  The table tools deal with
+ * the same data structure in a generic way and don't use/need mkchdr.
+ * You must not change the output of mkchdr otherwise the table encoder
+ * decoder, etc will not understand it.
+ *
+ * Mike Sample
+ *
+ * Copyright (C) 1993 Michael Sample
+ *            and the University of British Columbia
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program and the associated libraries are distributed in the hope
+ * that they will be useful, but WITHOUT ANY WARRANTY; without even the
+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ * PURPOSE.  See the GNU General Public License and GNU Library General
+ * Public License for more details.
+ *
+ * $Header: /usr/app/odstb/CVS/snacc/tbl-example/example.c,v 1.1 1997/02/15 19:33:26 rj Exp $
+ * $Log: example.c,v $
+ * Revision 1.1  1997/02/15 19:33:26  rj
+ * first check-in
+ *
+ */
+
+#include "tbl-incl.h"
+#include "exp-buf.h"
+#include "sbuf.h"
+
+#include "p-rec.h"  /* include the file we made with mkchdr */
+
+
+char *outputFileNameG = "p-rec.out.ber";
+
+void Usage PARAMS ((prg),
+    char *prg)
+{
+    fprintf (stderr, "Usage: %s <tt file name> <p-rec ber file> \n\n", prg);
+    fprintf (stderr, "E.g.  %s p-rec.tt  p-rec.ber\n\n", prg);
+    fprintf (stderr, "The BER values in the file list will be decoded, printed to stdout and then re-encoded to the file \"%s\"\n", outputFileNameG);
+}
+
+
+int
+main PARAMS ((argc, argv),
+    int argc _AND_
+    char **argv)
+{
+    char *tblFileName;
+    char *berFileName;
+    TBL *tbl;
+    int i;
+    char *fileData;
+    unsigned long int fsize;
+    PersonnelRecord *val;
+    unsigned long int bytesDecoded;
+    unsigned long int bytesEncoded;
+    SBuf sb;  /* use simple buffers for reading in (know sizes) */
+    ExpBuf *ebPtr; /* use expanding bufs for enc (usually don't know sizes)*/
+    GenBuf gb;
+    FILE *outputFile;
+
+
+
+    if (argc != 3)
+    {
+        Usage (argv[0]);
+        return 1;
+    }
+
+    tblFileName = argv[1];
+    berFileName = argv[2];
+
+    /* init mem pool to hold  decoded val */
+    InitNibbleMem (1024, 1024);
+
+    /* read in and decode the type table */
+    tbl = LoadTblFile (tblFileName);
+    if (tbl == NULL)
+        return 1;
+
+    fileData = LoadFile (berFileName, &fsize);
+    if (fileData == NULL)
+        return 1;
+
+    SBufInstallData (&sb, fileData, fsize);
+    PutSBufInGenBuf (&sb, &gb);
+
+    fprintf (stdout, "\n\n-- decoded contents of BER PersonnelRecord file: \"%s\"--\n", berFileName);
+
+    val = TblDecode (tbl, NULL, "PersonnelRecord", &gb, &bytesDecoded);
+
+    if (val == NULL)
+        fprintf (stdout, "-- Decoding error occured somewhere -- \n");
+    else
+        TblPrintValue (tbl, NULL, "PersonnelRecord", stdout, val);
+
+    fprintf (stdout, "\n\n -- decoded %d bytes for the above value --\n\n", bytesDecoded, berFileName);
+
+    free (fileData); /* was malloc'd in LoadFile */
+
+    /*
+     * process value here
+     * (This is where the header file generated by mkchdr is
+     * useful - you can access the decoded value in a standard
+     * /easier way).
+     *
+     * Ok, well, the names "field0" etc aren't that nice
+     * but what did you expect - they aren't named in the ASN.1
+     * spec so mkchdr just makes them up.  To fix this, just
+     * add field names to you ASN.1 spec - it will not change the
+     * way the values are encoded - so you're not making it
+     * incompatible with the original. (not including value notation)
+     */
+    printf ("The following printout is an example of using the\n");
+    printf ("hdr file generated by mkchdr to access the data\n");
+    printf ("returned from the table decoder.  Look in \"example.c\"\n\n");
+
+
+    printf ("***** JQ GUMBY & CO Database *****************************************\n");
+    printf ("Employee Name:      %s %s %s\n", val->field0->givenName->octs, val->field0->initial->octs, val->field0->familyName->octs);
+    printf ("Title:              %s\n", val->title->octs);
+    printf ("Employee Number:    %d\n", *val->field1);
+    printf ("Date of Hire:       %s\n", val->dateOfHire->octs);
+    printf ("Name of Spouse:     %s %s %s\n", val->nameOfSpouse->givenName->octs, val->nameOfSpouse->initial->octs, val->nameOfSpouse->familyName->octs);
+    printf ("Number of Children: %d\n", AsnListCount (val->children));
+    printf ("**********************************************************************\n\n");
+
+    /*
+     * finished playing with the decoded value.
+     * now re-encode the value.  Using an expbuf to hold the encoded val
+     * because they can grow and in general you can predict a values
+     * encoded size (although we could assume that is would be close to
+     * the same size as the one we read in at the beginning of this prg).
+     * (note: the size of PersonnelRecord BER value we decoded may be
+     * different from the size of the re-encoded version depending on
+     * the use of indefinite or definite lengths.  Both are valid BER.)
+     */
+    fprintf (stdout, "now re-encoding the PersonnelRecord value to \"%s\"\n", outputFileNameG);
+
+    ebPtr = ExpBufAllocBufAndData();
+    ExpBufResetInWriteRvsMode (ebPtr); /* set up to hold encoding (= writing) */
+
+    PutExpBufInGenBuf (ebPtr, &gb);
+
+    if (TblEncode (tbl, NULL, "PersonnelRecord", &gb, val, &bytesEncoded) < 0)
+        fprintf (stderr, "main: error encoding the PersonnelRecord\n");
+
+    /* copy ExpBuf data to file */
+    outputFile = fopen (outputFileNameG, "w");
+    if (outputFile == NULL)
+    {
+        fprintf (stderr, "error - could not open file \"%s\"\n", outputFileNameG);
+        perror ("main: fopen:");
+    }
+
+    ExpBufCopyToFile (ebPtr, outputFile);
+
+    fclose (outputFile);
+
+    /* free the encoded version */
+    ExpBufFreeBufAndDataList (ebPtr);
+
+
+    return 0;
+} /* main */
diff -uraN snacc-1.3bbn/tbl-example/makefile snacc-1.3b4/tbl-example/makefile
--- snacc-1.3bbn/tbl-example/makefile	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/tbl-example/makefile	1997-02-15 19:33:26.000000000 +0000
@@ -0,0 +1,82 @@
+# file: .../tbl-example/makefile
+#
+# $Header: /usr/app/odstb/CVS/snacc/tbl-example/makefile,v 1.1 1997/02/15 19:33:26 rj Exp $
+# $Log: makefile,v $
+# Revision 1.1  1997/02/15 19:33:26  rj
+# first check-in
+#
+
+include ../makehead
+
+TOP		= ..
+
+ASN1_SRC_DIR	= $(TOP)/asn1specs
+
+ASN1_C_LIB_DIR	= $(TOP)/c-lib
+ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
+TTBL_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1ctbl.a
+
+COMPILERDIR	= $(TOP)/compiler
+SNACC		= $(COMPILERDIR)/snacc
+USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
+SNACCFLAGS	= -u $(USEFUL_TYPES)
+
+TBLTOOLSDIR	= $(TOP)/tbl-tools
+MKHDR		= $(TBLTOOLSDIR)/mkchdr/mkchdr
+
+ASN1FILES	= $(ASN1_SRC_DIR)/p-rec.asn1
+ASN1TTFILE	= p-rec.tt
+ASN1TTHFILE	= p-rec.h
+
+CFILES	= example.c
+OFILES	= example.o
+
+DISTFILES = \
+	README		\
+	makefile	\
+	$(CFILES)	\
+	p-rec.ber
+
+CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_GEN_BUF
+
+#-------------------------------------------------------------------------------
+
+all::		example
+
+example:	$(OFILES) $(TTBL_ASN1_LIB)
+		$(REASON)
+		$(CC) $(CFLAGS) -o example $(OFILES) $(TTBL_ASN1_LIB) $(LIBS)
+
+$(ASN1TTFILE):	$(ASN1FILES)
+		$(REASON)
+		$(SNACC) $(SNACCFLAGS) -T $@ $(ASN1FILES)
+
+$(SNACC) $(MKHDR):
+		cd $(@D) && $(MAKE) $(@F)
+
+$(TTBL_ASN1_LIB):
+		cd $(@D) && $(MAKE) tbl-lib
+
+$(ASN1TTHFILE):	$(ASN1TTFILE)
+		$(REASON)
+		$(MKHDR) $? $@
+
+check::		example $(ASN1TTFILE)
+
+check::
+		./example p-rec.tt p-rec.ber
+		cmp p-rec.ber p-rec.out.ber
+		@echo "+++ the test was successful"
+
+# dummy:
+install::
+
+clean::
+		$(RM) example *.o *~ core .emacs* $(ASN1TTFILE) $(ASN1TTHFILE) p-rec.out.ber
+
+depend::
+		$(MAKE) $(MKHDR)
+
+depend::	$(ASN1TTHFILE)
+
+include ../maketail
diff -uraN snacc-1.3bbn/tbl-example/p-rec.ber.uu snacc-1.3b4/tbl-example/p-rec.ber.uu
--- snacc-1.3bbn/tbl-example/p-rec.ber.uu	1970-01-01 00:00:00.000000000 +0000
+++ snacc-1.3b4/tbl-example/p-rec.ber.uu	2005-07-30 16:57:00.588101736 +0000
@@ -0,0 +1,7 @@
+begin 644 p-rec.ber
+M8(&.81`6!$IO:&X6`446!5-M:71HH!`6#E1H92!":6<@0VAE97-E7X$``P&&
+MGZ$*0P@Q.3@R,#$P-*(281`6!$UA<GD6`4P6!5-M:71HHT$Q'V$1%@5*86UE
+M<Q8!4A8%4VUI=&B@"D,(,3DU-S`S,3`Q'F$0%@1,:7-A%@%-%@53;6ET:*`*
+*0P@Q.38Q,#8R,0``
+`
+end
